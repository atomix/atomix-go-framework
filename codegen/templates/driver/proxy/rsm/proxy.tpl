// Code generated by atomix-go-framework. DO NOT EDIT.

// SPDX-FileCopyrightText: 2019-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

package {{ .Package.Name }}

{{ $primitive := .Primitive }}

{{- define "type" }}{{ printf "%s.%s" .Package.Alias .Name }}{{ end }}

{{- $proxy := printf "%sProxyServer" .Generator.Prefix }}
{{- $service := printf "%s.%sServer" .Primitive.Type.Package.Alias .Primitive.Type.Name }}

{{- define "field" }}
{{- $path := .Field.Path }}
{{- range $index, $element := $path -}}
{{- if eq $index 0 -}}
{{- if isLast $path $index -}}
{{- if $element.Type.IsPointer -}}
.Get{{ $element.Name }}()
{{- else -}}
.{{ $element.Name }}
{{- end -}}
{{- else -}}
{{- if $element.Type.IsPointer -}}
.Get{{ $element.Name }}().
{{- else -}}
.{{ $element.Name }}.
{{- end -}}
{{- end -}}
{{- else -}}
{{- if isLast $path $index -}}
{{- if $element.Type.IsPointer -}}
    Get{{ $element.Name }}()
{{- else -}}
    {{ $element.Name -}}
{{- end -}}
{{- else -}}
{{- if $element.Type.IsPointer -}}
    Get{{ $element.Name }}().
{{- else -}}
    {{ $element.Name }}.
{{- end -}}
{{- end -}}
{{- end -}}
{{- end -}}
{{- end }}

{{- define "var" }}
{{- range $index, $element := .Field.Path -}}
{{- if eq $index 0 -}}
{{ .Name | toLowerCamel }}
{{- else -}}
{{ .Name }}
{{- end -}}
{{- end -}}
{{- end }}

{{- define "ref" -}}
{{- if not .Field.Type.IsPointer }}&{{ end }}
{{- end }}

{{- define "val" -}}
{{- if .Field.Type.IsPointer }}*{{ end }}
{{- end }}

{{- define "optype" }}
{{- if .Type.IsCommand -}}
Command
{{- else if .Type.IsQuery -}}
Query
{{- end -}}
{{- end }}

import (
	"context"
	"github.com/atomix/atomix-go-framework/pkg/atomix/driver/proxy/rsm"
	storage "github.com/atomix/atomix-go-framework/pkg/atomix/storage/protocol/rsm"
	"github.com/atomix/atomix-go-framework/pkg/atomix/errors"
	"github.com/atomix/atomix-go-framework/pkg/atomix/logging"
	"github.com/golang/protobuf/proto"
	{{- $package := .Package }}
	{{- range .Imports }}
	{{ .Alias }} {{ .Path | quote }}
	{{- end }}
	{{- range .Primitive.Methods }}
	{{- if .Scope.IsGlobal }}
	{{ import "github.com/atomix/atomix-go-framework/pkg/atomix/util/async" }}
	{{- end }}
	{{- if .Request.IsStream }}
	{{ import "io" }}
	{{- end }}
	{{- if or .Type.IsAsync .Response.IsStream }}
	{{ import "streams" "github.com/atomix/atomix-go-framework/pkg/atomix/stream" }}
	{{- end }}
	{{- if and .Scope.IsGlobal .Response.IsStream }}
	{{ import "sync" }}
	{{- end }}
	{{- end }}
)

const {{ printf "%sType" .Generator.Prefix }} = {{ .Primitive.Name | quote }}
{{ $root := . }}
const (
    {{- range .Primitive.Methods }}
    {{ (printf "%s%sOp" $root.Generator.Prefix .Name) | toLowerCamel }} storage.OperationID = {{ .ID }}
    {{- end }}
)

var log = logging.GetLogger("atomix", "proxy", {{ .Primitive.Name | lower | quote }})

// New{{ $proxy }} creates a new {{ $proxy }}
func New{{ $proxy }}(client *rsm.Client, readSync bool) {{ $service }} {
	return &{{ $proxy }}{
		Client:   client,
		readSync: readSync,
	}
}

type {{ $proxy }} struct {
	*rsm.Client
	readSync bool
	log      logging.Logger
}

{{- range .Primitive.Methods }}
{{- $name := ((printf "%s%sOp" $root.Generator.Prefix .Name) | toLowerCamel) }}
{{- $method := . }}
{{ if and .Response.IsUnary .Type.IsSync }}
func (s *{{ $proxy }}) {{ .Name }}(ctx context.Context, request *{{ template "type" .Request.Type }}) (*{{ template "type" .Response.Type }}, error) {
	log.Debugf("Received {{ .Request.Type.Name }} %.250s", request)
	input, err := proto.Marshal(request)
	if err != nil {
        log.Errorf("Request {{ .Request.Type.Name }} failed: %v", err)
	    return nil, errors.Proto(err)
	}

	{{- if .Scope.IsPartition }}
	{{- if .Request.PartitionKey }}
	partitionKey := {{ template "val" .Request.PartitionKey }}request{{ template "field" .Request.PartitionKey }}
	{{- if and .Request.PartitionKey.Field.Type.IsBytes (not .Request.PartitionKey.Field.Type.IsCast) }}
	partition := s.PartitionBy(partitionKey)
	{{- else }}
	{{- if .Request.PartitionKey.Field.Type.IsString }}
    partition := s.PartitionBy([]byte(partitionKey))
    {{- else }}
    partition := s.PartitionBy([]byte(partitionKey.String()))
    {{- end }}
	{{- end }}
	{{- else if .Request.PartitionRange }}
	partitionRange := {{ template "val" .Request.PartitionRange }}request{{ template "field" .Request.PartitionRange }}
	{{- else }}
	clusterKey := request.Headers.ClusterKey
	if clusterKey == "" {
	    clusterKey = request{{ template "field" .Request.Headers }}.PrimitiveID.String()
	}
    partition := s.PartitionBy([]byte(clusterKey))
	{{- end }}

	serviceInfo := storage.ServiceInfo{
		Type:      storage.ServiceType(Type),
		Namespace: s.Namespace,
		Name:      request{{ template "field" .Request.Headers }}.PrimitiveID.Name,
	}
	service, err := partition.GetService(ctx, serviceInfo)
	if err != nil {
        log.Errorf("Request {{ .Request.Type.Name }} failed: %v", err)
		return nil, errors.Proto(err)
	}
    {{- if .Type.IsCommand }}
	output, err := service.DoCommand(ctx, {{ $name }}, input)
    {{- else }}
	output, err := service.DoQuery(ctx, {{ $name }}, input, s.readSync)
    {{- end }}
	if err != nil {
        log.Debugf("Request {{ .Request.Type.Name }} failed: %v", err)
	    return nil, errors.Proto(err)
	}

	response := &{{ template "type" .Response.Type }}{}
	err = proto.Unmarshal(output, response)
	if err != nil {
        log.Errorf("Request {{ .Request.Type.Name }} failed: %v", err)
	    return nil, errors.Proto(err)
	}
	{{- else if .Scope.IsGlobal }}
	partitions := s.Partitions()
	{{- $aggregates := false }}
    {{- range .Response.Aggregates }}
    {{- $aggregates = true }}
    {{- end }}

	serviceInfo := storage.ServiceInfo{
		Type:      storage.ServiceType(Type),
		Namespace: s.Namespace,
		Name:      request{{ template "field" .Request.Headers }}.PrimitiveID.Name,
	}
	{{- if .Response.Aggregates }}
	outputs, err := async.ExecuteAsync(len(partitions), func(i int) (interface{}, error) {
        service, err := partitions[i].GetService(ctx, serviceInfo)
        if err != nil {
            return nil, err
        }
        {{- if .Type.IsCommand }}
		return service.DoCommand(ctx, {{ $name }}, input)
        {{- else }}
		return service.DoQuery(ctx, {{ $name }}, input, s.readSync)
        {{- end }}
	})
	{{- else }}
	err = async.IterAsync(len(partitions), func(i int) error {
        service, err := partitions[i].GetService(ctx, serviceInfo)
        if err != nil {
            return err
        }
        {{- if .Type.IsCommand }}
		_, err = service.DoCommand(ctx, {{ $name }}, input)
        {{- else }}
		_, err = service.DoQuery(ctx, {{ $name }}, input, s.readSync)
        {{- end }}
		return err
	})
	{{- end }}
	if err != nil {
        log.Debugf("Request {{ .Request.Type.Name }} failed: %v", err)
	    return nil, errors.Proto(err)
	}

	{{- if .Response.Aggregates }}
	responses := make([]{{ template "type" $method.Response.Type }}, 0, len(outputs))
	for _, output := range outputs {
	    var response {{ template "type" $method.Response.Type }}
        err := proto.Unmarshal(output.([]byte), &response)
        if err != nil {
            log.Errorf("Request {{ $method.Request.Type.Name }} failed: %v", err)
            return nil, errors.Proto(err)
        }
        responses = append(responses, response)
	}
	{{- end }}

	response := &{{ template "type" $method.Response.Type }}{}
    {{- range .Response.Aggregates }}
    {{- if .IsChooseFirst }}
    response{{ template "field" . }} = responses[0]{{ template "field" . }}
    {{- else if .IsAppend }}
    for _, r := range responses {
        response{{ template "field" . }} = append(response{{ template "field" . }}, r{{ template "field" . }}...)
    }
    {{- else if .IsSum }}
    for _, r := range responses {
        response{{ template "field" . }} += r{{ template "field" . }}
    }
    {{- end }}
	{{- end }}
	{{- end }}
	log.Debugf("Sending {{ .Response.Type.Name }} %.250s", response)
	return response, nil
}
{{ else if .Type.IsAsync }}
func (s *{{ $proxy }}) {{ .Name }}(ctx context.Context, request *{{ template "type" .Request.Type }}) (*{{ template "type" .Response.Type }}, error) {
	log.Debugf("Received {{ .Request.Type.Name }} %.250s", request)
	input, err := proto.Marshal(request)
	if err != nil {
        log.Errorf("Request {{ .Request.Type.Name }} failed: %v", err)
	    return nil, errors.Proto(err)
	}

	{{- if .Scope.IsPartition }}
	{{- if .Request.PartitionKey }}
	partitionKey := {{ template "val" .Request.PartitionKey }}request{{ template "field" .Request.PartitionKey }}
	{{- if and .Request.PartitionKey.Field.Type.IsBytes (not .Request.PartitionKey.Field.Type.IsCast) }}
	partition := s.PartitionBy(partitionKey)
	{{- else }}
	{{- if .Request.PartitionKey.Field.Type.IsString }}
    partition := s.PartitionBy([]byte(partitionKey))
    {{- else }}
    partition := s.PartitionBy([]byte(partitionKey.String()))
    {{- end }}
	{{- end }}
	{{- else if .Request.PartitionRange }}
	partitionRange := {{ template "val" .Request.PartitionRange }}request{{ template "field" .Request.PartitionRange }}
	{{- else }}
	clusterKey := request.Headers.ClusterKey
	if clusterKey == "" {
	    clusterKey = request{{ template "field" .Request.Headers }}.PrimitiveID.String()
	}
    partition := s.PartitionBy([]byte(clusterKey))
	{{- end }}

	serviceInfo := storage.ServiceInfo{
		Type:      storage.ServiceType(Type),
		Namespace: s.Namespace,
		Name:      request{{ template "field" .Request.Headers }}.PrimitiveID.Name,
	}
	service, err := partition.GetService(ctx, serviceInfo)
    if err != nil {
        return nil, err
    }

    ch := make(chan streams.Result)
	stream := streams.NewChannelStream(ch)
	{{- if .Type.IsCommand }}
	err = service.DoCommandStream(ctx, {{ $name }}, input, stream)
	{{- else }}
	err = service.DoQueryStream(ctx, {{ $name }}, input, stream, s.readSync)
	{{- end }}
	if err != nil {
        log.Debugf("Request {{ .Request.Type.Name }} failed: %v", err)
	    return nil, errors.Proto(err)
	}

	result, ok := <- ch
	if !ok {
	    return nil, context.Canceled
	}

    if result.Failed() {
        log.Debugf("Request {{ .Request.Type.Name }} failed: %v", result.Error)
        return nil, errors.Proto(result.Error)
    }

    response := &{{ template "type" .Response.Type }}{}
    err = proto.Unmarshal(result.Value.([]byte), response)
    if err != nil {
        log.Errorf("Request {{ .Request.Type.Name }} failed: %v", err)
        return nil, errors.Proto(err)
    }
	{{- else if .Scope.IsGlobal }}
	serviceInfo := storage.ServiceInfo{
		Type:      storage.ServiceType(Type),
		Namespace: s.Namespace,
		Name:      request{{ template "field" .Request.Headers }}.PrimitiveID.Name,
	}
	partitions := s.Partitions()
	outputs, err := async.ExecuteAsync(len(partitions), func(i int) (interface{}, error) {
        service, err := partitions[i].GetService(srv.Context(), serviceInfo)
        if err != nil {
            return nil, err
        }
        ch := make(chan streams.Result)
        stream := streams.NewChannelStream(ch)
        {{- if .Type.IsCommand }}
		err = service.DoCommandStream(srv.Context(), {{ $name }}, input, stream)
        {{- else }}
		err = service.DoQueryStream(srv.Context(), {{ $name }}, input, stream, s.readSync)
        {{- end }}
		if err != nil {
		    return nil, err
		}

        result, ok := <- ch
        if !ok {
            return nil, context.Canceled
        }

        if result.Failed() {
            return nil, errors.Proto(result.Error)
        }

        response := &{{ template "type" .Response.Type }}{}
        err = proto.Unmarshal(result.Value.([]byte), response)
        if err != nil {
            log.Errorf("Request {{ .Request.Type.Name }} failed: %v", err)
            return nil, errors.Proto(err)
        }
        return response, nil
	})

	{{- if .Response.Aggregates }}
	responses := make([]{{ template "type" $method.Response.Type }}, 0, len(outputs))
	for _, output := range outputs {
	    var response {{ template "type" $method.Response.Type }}
        err := proto.Unmarshal(output.([]byte), &response)
        if err != nil {
            log.Errorf("Request {{ $method.Request.Type.Name }} failed: %v", err)
            return nil, errors.Proto(err)
        }
        responses = append(responses, response)
	}
	{{- end }}

	response := &{{ template "type" $method.Response.Type }}{}
    {{- range .Response.Aggregates }}
    {{- if .IsChooseFirst }}
    response{{ template "field" . }} = responses[0]{{ template "field" . }}
    {{- else if .IsAppend }}
    for _, r := range responses {
        response{{ template "field" . }} = append(response{{ template "field" . }}, r{{ template "field" . }}...)
    }
    {{- else if .IsSum }}
    for _, r := range responses {
        response{{ template "field" . }} += r{{ template "field" . }}
    }
    {{- end }}
	{{- end }}
	{{- end }}
	log.Debugf("Sending {{ .Response.Type.Name }} %.250s", response)
	return response, nil
}
{{ else if .Response.IsStream }}
func (s *{{ $proxy }}) {{ .Name }}(request *{{ template "type" .Request.Type }}, srv {{ template "type" $primitive.Type }}_{{ .Name }}Server) error {
    log.Debugf("Received {{ .Request.Type.Name }} %.250s", request)
	input, err := proto.Marshal(request)
	if err != nil {
        log.Errorf("Request {{ .Request.Type.Name }} failed: %v", err)
        return errors.Proto(err)
	}

	{{- if .Scope.IsPartition }}
	{{- if .Request.PartitionKey }}
	partitionKey := {{ template "val" .Request.PartitionKey }}request{{ template "field" .Request.PartitionKey }}
	{{- if and .Request.PartitionKey.Field.Type.IsBytes (not .Request.PartitionKey.Field.Type.IsCast) }}
	partition := s.PartitionBy(partitionKey)
	{{- else }}
	{{- if .Request.PartitionKey.Field.Type.IsString }}
    partition := s.PartitionBy([]byte(partitionKey))
    {{- else }}
    partition := s.PartitionBy([]byte(partitionKey.String()))
    {{- end }}
	{{- end }}
	{{- else if .Request.PartitionRange }}
	partitionRange := {{ template "val" .Request.PartitionRange }}request{{ template "field" .Request.PartitionRange }}
	{{- else }}
	clusterKey := request.Headers.ClusterKey
	if clusterKey == "" {
	    clusterKey = request{{ template "field" .Request.Headers }}.PrimitiveID.String()
	}
    partition := s.PartitionBy([]byte(clusterKey))
	{{- end }}

	serviceInfo := storage.ServiceInfo{
		Type:      storage.ServiceType(Type),
		Namespace: s.Namespace,
		Name:      request{{ template "field" .Request.Headers }}.PrimitiveID.Name,
	}
    service, err := partition.GetService(srv.Context(), serviceInfo)
    if err != nil {
        return err
    }

	stream := streams.NewBufferedStream()
    {{- if .Type.IsCommand }}
	err = service.DoCommandStream(srv.Context(), {{ $name }}, input, stream)
    {{- else }}
	err = service.DoQueryStream(srv.Context(), {{ $name }}, input, stream, s.readSync)
    {{- end }}
	if err != nil {
        log.Debugf("Request {{ .Request.Type.Name }} failed: %v", err)
	    return errors.Proto(err)
	}

    ch := make(chan streams.Result)
	go func() {
        defer close(ch)
		for {
			result, ok := stream.Receive()
			if !ok {
    			return
			}
			ch <- result
		}
	}()
	{{- else if .Scope.IsGlobal }}
	serviceInfo := storage.ServiceInfo{
		Type:      storage.ServiceType(Type),
		Namespace: s.Namespace,
		Name:      request{{ template "field" .Request.Headers }}.PrimitiveID.Name,
	}
    ch := make(chan streams.Result)
	partitions := s.Partitions()
	wg := &sync.WaitGroup{}
	err = async.IterAsync(len(partitions), func(i int) error {
		service, err := partitions[i].GetService(srv.Context(), serviceInfo)
		if err != nil {
			return err
		}

	    stream := streams.NewBufferedStream()
        {{- if .Type.IsCommand }}
		err = service.DoCommandStream(srv.Context(), {{ $name }}, input, stream)
        {{- else }}
		err = service.DoQueryStream(srv.Context(), {{ $name }}, input, stream, s.readSync)
        {{- end }}
		if err != nil {
			return err
		}
		wg.Add(1)
		go func() {
		    defer wg.Done()
            for {
                result, ok := stream.Receive()
                if !ok {
                    return
                }
                ch <- result
            }
		}()
		return nil
	})
	if err != nil {
        log.Debugf("Request {{ .Request.Type.Name }} failed: %v", err)
	    return errors.Proto(err)
	}

	go func() {
	    wg.Wait()
	    close(ch)
	}()
	{{- end }}

    for result := range ch {
		if result.Failed() {
		    if result.Error == context.Canceled {
		        break
			}
			log.Debugf("Request {{ .Request.Type.Name }} failed: %v", result.Error)
			return errors.Proto(result.Error)
		}

		response := &{{ template "type" .Response.Type }}{}
        err = proto.Unmarshal(result.Value.([]byte), response)
        if err != nil {
            log.Errorf("Request {{ .Request.Type.Name }} failed: %v", err)
            return errors.Proto(err)
        }

		log.Debugf("Sending {{ .Response.Type.Name }} %.250s", response)
		if err = srv.Send(response); err != nil {
            log.Warnf("Response {{ .Response.Type.Name }} failed: %v", err)
			return err
		}
	}
	log.Debugf("Finished {{ .Request.Type.Name }} %.250s", request)
	return nil
}
{{ end }}
{{- end }}
