// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: atomix/storage/protocol/rsm2/service.proto

package rsm

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PartitionResponseCode int32

const (
	PartitionResponseCode_PARTITION_OK         PartitionResponseCode = 0
	PartitionResponseCode_PARTITION_ERROR      PartitionResponseCode = 1
	PartitionResponseCode_PARTITION_NOT_LEADER PartitionResponseCode = 2
)

var PartitionResponseCode_name = map[int32]string{
	0: "PARTITION_OK",
	1: "PARTITION_ERROR",
	2: "PARTITION_NOT_LEADER",
}

var PartitionResponseCode_value = map[string]int32{
	"PARTITION_OK":         0,
	"PARTITION_ERROR":      1,
	"PARTITION_NOT_LEADER": 2,
}

func (x PartitionResponseCode) String() string {
	return proto.EnumName(PartitionResponseCode_name, int32(x))
}

func (PartitionResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{0}
}

type SessionResponseType int32

const (
	SessionResponseType_RESPONSE        SessionResponseType = 0
	SessionResponseType_STREAM_OPEN     SessionResponseType = 1
	SessionResponseType_STREAM_RESPONSE SessionResponseType = 2
	SessionResponseType_STREAM_CLOSE    SessionResponseType = 3
)

var SessionResponseType_name = map[int32]string{
	0: "RESPONSE",
	1: "STREAM_OPEN",
	2: "STREAM_RESPONSE",
	3: "STREAM_CLOSE",
}

var SessionResponseType_value = map[string]int32{
	"RESPONSE":        0,
	"STREAM_OPEN":     1,
	"STREAM_RESPONSE": 2,
	"STREAM_CLOSE":    3,
}

func (x SessionResponseType) String() string {
	return proto.EnumName(SessionResponseType_name, int32(x))
}

func (SessionResponseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{1}
}

type SessionResponseCode int32

const (
	SessionResponseCode_OK             SessionResponseCode = 0
	SessionResponseCode_ERROR          SessionResponseCode = 1
	SessionResponseCode_UNKNOWN        SessionResponseCode = 2
	SessionResponseCode_CANCELED       SessionResponseCode = 3
	SessionResponseCode_NOT_FOUND      SessionResponseCode = 4
	SessionResponseCode_ALREADY_EXISTS SessionResponseCode = 5
	SessionResponseCode_UNAUTHORIZED   SessionResponseCode = 6
	SessionResponseCode_FORBIDDEN      SessionResponseCode = 7
	SessionResponseCode_CONFLICT       SessionResponseCode = 8
	SessionResponseCode_INVALID        SessionResponseCode = 9
	SessionResponseCode_UNAVAILABLE    SessionResponseCode = 10
	SessionResponseCode_NOT_SUPPORTED  SessionResponseCode = 11
	SessionResponseCode_TIMEOUT        SessionResponseCode = 12
	SessionResponseCode_INTERNAL       SessionResponseCode = 13
)

var SessionResponseCode_name = map[int32]string{
	0:  "OK",
	1:  "ERROR",
	2:  "UNKNOWN",
	3:  "CANCELED",
	4:  "NOT_FOUND",
	5:  "ALREADY_EXISTS",
	6:  "UNAUTHORIZED",
	7:  "FORBIDDEN",
	8:  "CONFLICT",
	9:  "INVALID",
	10: "UNAVAILABLE",
	11: "NOT_SUPPORTED",
	12: "TIMEOUT",
	13: "INTERNAL",
}

var SessionResponseCode_value = map[string]int32{
	"OK":             0,
	"ERROR":          1,
	"UNKNOWN":        2,
	"CANCELED":       3,
	"NOT_FOUND":      4,
	"ALREADY_EXISTS": 5,
	"UNAUTHORIZED":   6,
	"FORBIDDEN":      7,
	"CONFLICT":       8,
	"INVALID":        9,
	"UNAVAILABLE":    10,
	"NOT_SUPPORTED":  11,
	"TIMEOUT":        12,
	"INTERNAL":       13,
}

func (x SessionResponseCode) String() string {
	return proto.EnumName(SessionResponseCode_name, int32(x))
}

func (SessionResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{2}
}

type StateMachineSnapshot struct {
	Index     Index              `protobuf:"varint,1,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	Timestamp time.Time          `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Services  []*ServiceSnapshot `protobuf:"bytes,3,rep,name=services,proto3" json:"services,omitempty"`
}

func (m *StateMachineSnapshot) Reset()         { *m = StateMachineSnapshot{} }
func (m *StateMachineSnapshot) String() string { return proto.CompactTextString(m) }
func (*StateMachineSnapshot) ProtoMessage()    {}
func (*StateMachineSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{0}
}
func (m *StateMachineSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineSnapshot.Merge(m, src)
}
func (m *StateMachineSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineSnapshot proto.InternalMessageInfo

func (m *StateMachineSnapshot) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StateMachineSnapshot) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *StateMachineSnapshot) GetServices() []*ServiceSnapshot {
	if m != nil {
		return m.Services
	}
	return nil
}

// Service snapshot
type ServiceSnapshot struct {
	ServiceID ServiceID          `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3,casttype=ServiceID" json:"service_id"`
	Index     Index              `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	Sessions  []*SessionSnapshot `protobuf:"bytes,3,rep,name=sessions,proto3" json:"sessions,omitempty"`
	Data      []byte             `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ServiceSnapshot) Reset()         { *m = ServiceSnapshot{} }
func (m *ServiceSnapshot) String() string { return proto.CompactTextString(m) }
func (*ServiceSnapshot) ProtoMessage()    {}
func (*ServiceSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{1}
}
func (m *ServiceSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceSnapshot.Merge(m, src)
}
func (m *ServiceSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *ServiceSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceSnapshot proto.InternalMessageInfo

func (m *ServiceSnapshot) GetServiceID() ServiceID {
	if m != nil {
		return m.ServiceID
	}
	return ServiceID{}
}

func (m *ServiceSnapshot) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ServiceSnapshot) GetSessions() []*SessionSnapshot {
	if m != nil {
		return m.Sessions
	}
	return nil
}

func (m *ServiceSnapshot) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Service session
type SessionSnapshot struct {
	SessionID        SessionID                `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	Timestamp        time.Time                `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	LastRequestID    RequestID                `protobuf:"varint,3,opt,name=last_request_id,json=lastRequestId,proto3,casttype=RequestID" json:"last_request_id,omitempty"`
	LastResponseID   ResponseID               `protobuf:"varint,4,opt,name=last_response_id,json=lastResponseId,proto3,casttype=ResponseID" json:"last_response_id,omitempty"`
	PendingResponses []*SessionWriteResponse  `protobuf:"bytes,5,rep,name=pending_responses,json=pendingResponses,proto3" json:"pending_responses,omitempty"`
	Streams          []*SessionStreamSnapshot `protobuf:"bytes,6,rep,name=streams,proto3" json:"streams,omitempty"`
}

func (m *SessionSnapshot) Reset()         { *m = SessionSnapshot{} }
func (m *SessionSnapshot) String() string { return proto.CompactTextString(m) }
func (*SessionSnapshot) ProtoMessage()    {}
func (*SessionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{2}
}
func (m *SessionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionSnapshot.Merge(m, src)
}
func (m *SessionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *SessionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_SessionSnapshot proto.InternalMessageInfo

func (m *SessionSnapshot) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionSnapshot) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *SessionSnapshot) GetLastRequestID() RequestID {
	if m != nil {
		return m.LastRequestID
	}
	return 0
}

func (m *SessionSnapshot) GetLastResponseID() ResponseID {
	if m != nil {
		return m.LastResponseID
	}
	return 0
}

func (m *SessionSnapshot) GetPendingResponses() []*SessionWriteResponse {
	if m != nil {
		return m.PendingResponses
	}
	return nil
}

func (m *SessionSnapshot) GetStreams() []*SessionStreamSnapshot {
	if m != nil {
		return m.Streams
	}
	return nil
}

// Service session stream
type SessionStreamSnapshot struct {
	StreamID    StreamID    `protobuf:"varint,1,opt,name=stream_id,json=streamId,proto3,casttype=StreamID" json:"stream_id,omitempty"`
	OperationID OperationID `protobuf:"bytes,3,opt,name=operation_id,json=operationId,proto3,casttype=OperationID" json:"operation_id,omitempty"`
}

func (m *SessionStreamSnapshot) Reset()         { *m = SessionStreamSnapshot{} }
func (m *SessionStreamSnapshot) String() string { return proto.CompactTextString(m) }
func (*SessionStreamSnapshot) ProtoMessage()    {}
func (*SessionStreamSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{3}
}
func (m *SessionStreamSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionStreamSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionStreamSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionStreamSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionStreamSnapshot.Merge(m, src)
}
func (m *SessionStreamSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *SessionStreamSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionStreamSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_SessionStreamSnapshot proto.InternalMessageInfo

func (m *SessionStreamSnapshot) GetStreamID() StreamID {
	if m != nil {
		return m.StreamID
	}
	return 0
}

func (m *SessionStreamSnapshot) GetOperationID() OperationID {
	if m != nil {
		return m.OperationID
	}
	return ""
}

type ServiceId struct {
	Type    string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Cluster string `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	Name    string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ServiceId) Reset()         { *m = ServiceId{} }
func (m *ServiceId) String() string { return proto.CompactTextString(m) }
func (*ServiceId) ProtoMessage()    {}
func (*ServiceId) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{4}
}
func (m *ServiceId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceId.Merge(m, src)
}
func (m *ServiceId) XXX_Size() int {
	return m.Size()
}
func (m *ServiceId) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceId.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceId proto.InternalMessageInfo

func (m *ServiceId) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ServiceId) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ServiceId) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PartitionReadRequest struct {
	PartitionID uint32             `protobuf:"varint,1,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	Request     ServiceReadRequest `protobuf:"bytes,2,opt,name=request,proto3" json:"request"`
}

func (m *PartitionReadRequest) Reset()         { *m = PartitionReadRequest{} }
func (m *PartitionReadRequest) String() string { return proto.CompactTextString(m) }
func (*PartitionReadRequest) ProtoMessage()    {}
func (*PartitionReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{5}
}
func (m *PartitionReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionReadRequest.Merge(m, src)
}
func (m *PartitionReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartitionReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionReadRequest proto.InternalMessageInfo

func (m *PartitionReadRequest) GetPartitionID() uint32 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

func (m *PartitionReadRequest) GetRequest() ServiceReadRequest {
	if m != nil {
		return m.Request
	}
	return ServiceReadRequest{}
}

type PartitionReadResponse struct {
	Status   PartitionResponseStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status"`
	Response ServiceReadResponse     `protobuf:"bytes,2,opt,name=response,proto3" json:"response"`
}

func (m *PartitionReadResponse) Reset()         { *m = PartitionReadResponse{} }
func (m *PartitionReadResponse) String() string { return proto.CompactTextString(m) }
func (*PartitionReadResponse) ProtoMessage()    {}
func (*PartitionReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{6}
}
func (m *PartitionReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionReadResponse.Merge(m, src)
}
func (m *PartitionReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *PartitionReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionReadResponse proto.InternalMessageInfo

func (m *PartitionReadResponse) GetStatus() PartitionResponseStatus {
	if m != nil {
		return m.Status
	}
	return PartitionResponseStatus{}
}

func (m *PartitionReadResponse) GetResponse() ServiceReadResponse {
	if m != nil {
		return m.Response
	}
	return ServiceReadResponse{}
}

type StateMachineReadRequest struct {
	Request ServiceReadRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request"`
}

func (m *StateMachineReadRequest) Reset()         { *m = StateMachineReadRequest{} }
func (m *StateMachineReadRequest) String() string { return proto.CompactTextString(m) }
func (*StateMachineReadRequest) ProtoMessage()    {}
func (*StateMachineReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{7}
}
func (m *StateMachineReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineReadRequest.Merge(m, src)
}
func (m *StateMachineReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineReadRequest proto.InternalMessageInfo

func (m *StateMachineReadRequest) GetRequest() ServiceReadRequest {
	if m != nil {
		return m.Request
	}
	return ServiceReadRequest{}
}

type StateMachineReadResponse struct {
	Response ServiceReadResponse `protobuf:"bytes,1,opt,name=response,proto3" json:"response"`
}

func (m *StateMachineReadResponse) Reset()         { *m = StateMachineReadResponse{} }
func (m *StateMachineReadResponse) String() string { return proto.CompactTextString(m) }
func (*StateMachineReadResponse) ProtoMessage()    {}
func (*StateMachineReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{8}
}
func (m *StateMachineReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineReadResponse.Merge(m, src)
}
func (m *StateMachineReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineReadResponse proto.InternalMessageInfo

func (m *StateMachineReadResponse) GetResponse() ServiceReadResponse {
	if m != nil {
		return m.Response
	}
	return ServiceReadResponse{}
}

type ServiceReadRequest struct {
	ServiceID ServiceID          `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3,casttype=ServiceID" json:"service_id"`
	Request   SessionReadRequest `protobuf:"bytes,2,opt,name=request,proto3" json:"request"`
}

func (m *ServiceReadRequest) Reset()         { *m = ServiceReadRequest{} }
func (m *ServiceReadRequest) String() string { return proto.CompactTextString(m) }
func (*ServiceReadRequest) ProtoMessage()    {}
func (*ServiceReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{9}
}
func (m *ServiceReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceReadRequest.Merge(m, src)
}
func (m *ServiceReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServiceReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceReadRequest proto.InternalMessageInfo

func (m *ServiceReadRequest) GetServiceID() ServiceID {
	if m != nil {
		return m.ServiceID
	}
	return ServiceID{}
}

func (m *ServiceReadRequest) GetRequest() SessionReadRequest {
	if m != nil {
		return m.Request
	}
	return SessionReadRequest{}
}

type ServiceReadResponse struct {
	Response SessionReadResponse `protobuf:"bytes,1,opt,name=response,proto3" json:"response"`
}

func (m *ServiceReadResponse) Reset()         { *m = ServiceReadResponse{} }
func (m *ServiceReadResponse) String() string { return proto.CompactTextString(m) }
func (*ServiceReadResponse) ProtoMessage()    {}
func (*ServiceReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{10}
}
func (m *ServiceReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceReadResponse.Merge(m, src)
}
func (m *ServiceReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *ServiceReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceReadResponse proto.InternalMessageInfo

func (m *ServiceReadResponse) GetResponse() SessionReadResponse {
	if m != nil {
		return m.Response
	}
	return SessionReadResponse{}
}

type SessionReadRequest struct {
	SessionID     SessionID `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	LastRequestID RequestID `protobuf:"varint,2,opt,name=last_request_id,json=lastRequestId,proto3,casttype=RequestID" json:"last_request_id,omitempty"`
	LastIndex     Index     `protobuf:"varint,3,opt,name=last_index,json=lastIndex,proto3,casttype=Index" json:"last_index,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*SessionReadRequest_Query
	Request isSessionReadRequest_Request `protobuf_oneof:"request"`
}

func (m *SessionReadRequest) Reset()         { *m = SessionReadRequest{} }
func (m *SessionReadRequest) String() string { return proto.CompactTextString(m) }
func (*SessionReadRequest) ProtoMessage()    {}
func (*SessionReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{11}
}
func (m *SessionReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionReadRequest.Merge(m, src)
}
func (m *SessionReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *SessionReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SessionReadRequest proto.InternalMessageInfo

type isSessionReadRequest_Request interface {
	isSessionReadRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionReadRequest_Query struct {
	Query *QueryRequest `protobuf:"bytes,4,opt,name=query,proto3,oneof" json:"query,omitempty"`
}

func (*SessionReadRequest_Query) isSessionReadRequest_Request() {}

func (m *SessionReadRequest) GetRequest() isSessionReadRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SessionReadRequest) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionReadRequest) GetLastRequestID() RequestID {
	if m != nil {
		return m.LastRequestID
	}
	return 0
}

func (m *SessionReadRequest) GetLastIndex() Index {
	if m != nil {
		return m.LastIndex
	}
	return 0
}

func (m *SessionReadRequest) GetQuery() *QueryRequest {
	if x, ok := m.GetRequest().(*SessionReadRequest_Query); ok {
		return x.Query
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionReadRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionReadRequest_Query)(nil),
	}
}

type SessionReadResponse struct {
	Type   SessionResponseType   `protobuf:"varint,1,opt,name=type,proto3,enum=atomix.service.SessionResponseType" json:"type,omitempty"`
	Status SessionResponseStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status"`
	Index  Index                 `protobuf:"varint,3,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	// Types that are valid to be assigned to Response:
	//	*SessionReadResponse_Query
	Response isSessionReadResponse_Response `protobuf_oneof:"response"`
}

func (m *SessionReadResponse) Reset()         { *m = SessionReadResponse{} }
func (m *SessionReadResponse) String() string { return proto.CompactTextString(m) }
func (*SessionReadResponse) ProtoMessage()    {}
func (*SessionReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{12}
}
func (m *SessionReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionReadResponse.Merge(m, src)
}
func (m *SessionReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *SessionReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SessionReadResponse proto.InternalMessageInfo

type isSessionReadResponse_Response interface {
	isSessionReadResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionReadResponse_Query struct {
	Query *QueryResponse `protobuf:"bytes,4,opt,name=query,proto3,oneof" json:"query,omitempty"`
}

func (*SessionReadResponse_Query) isSessionReadResponse_Response() {}

func (m *SessionReadResponse) GetResponse() isSessionReadResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SessionReadResponse) GetType() SessionResponseType {
	if m != nil {
		return m.Type
	}
	return SessionResponseType_RESPONSE
}

func (m *SessionReadResponse) GetStatus() SessionResponseStatus {
	if m != nil {
		return m.Status
	}
	return SessionResponseStatus{}
}

func (m *SessionReadResponse) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SessionReadResponse) GetQuery() *QueryResponse {
	if x, ok := m.GetResponse().(*SessionReadResponse_Query); ok {
		return x.Query
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionReadResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionReadResponse_Query)(nil),
	}
}

type PartitionWriteRequest struct {
	PartitionID uint32              `protobuf:"varint,1,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	Request     ServiceWriteRequest `protobuf:"bytes,2,opt,name=request,proto3" json:"request"`
}

func (m *PartitionWriteRequest) Reset()         { *m = PartitionWriteRequest{} }
func (m *PartitionWriteRequest) String() string { return proto.CompactTextString(m) }
func (*PartitionWriteRequest) ProtoMessage()    {}
func (*PartitionWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{13}
}
func (m *PartitionWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionWriteRequest.Merge(m, src)
}
func (m *PartitionWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartitionWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionWriteRequest proto.InternalMessageInfo

func (m *PartitionWriteRequest) GetPartitionID() uint32 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

func (m *PartitionWriteRequest) GetRequest() ServiceWriteRequest {
	if m != nil {
		return m.Request
	}
	return ServiceWriteRequest{}
}

type PartitionWriteResponse struct {
	Status   PartitionResponseStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status"`
	Response ServiceWriteResponse    `protobuf:"bytes,2,opt,name=response,proto3" json:"response"`
}

func (m *PartitionWriteResponse) Reset()         { *m = PartitionWriteResponse{} }
func (m *PartitionWriteResponse) String() string { return proto.CompactTextString(m) }
func (*PartitionWriteResponse) ProtoMessage()    {}
func (*PartitionWriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{14}
}
func (m *PartitionWriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionWriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionWriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionWriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionWriteResponse.Merge(m, src)
}
func (m *PartitionWriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *PartitionWriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionWriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionWriteResponse proto.InternalMessageInfo

func (m *PartitionWriteResponse) GetStatus() PartitionResponseStatus {
	if m != nil {
		return m.Status
	}
	return PartitionResponseStatus{}
}

func (m *PartitionWriteResponse) GetResponse() ServiceWriteResponse {
	if m != nil {
		return m.Response
	}
	return ServiceWriteResponse{}
}

type PartitionResponseStatus struct {
	Code   PartitionResponseCode `protobuf:"varint,1,opt,name=code,proto3,enum=atomix.service.PartitionResponseCode" json:"code,omitempty"`
	Leader string                `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
}

func (m *PartitionResponseStatus) Reset()         { *m = PartitionResponseStatus{} }
func (m *PartitionResponseStatus) String() string { return proto.CompactTextString(m) }
func (*PartitionResponseStatus) ProtoMessage()    {}
func (*PartitionResponseStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{15}
}
func (m *PartitionResponseStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionResponseStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionResponseStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionResponseStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionResponseStatus.Merge(m, src)
}
func (m *PartitionResponseStatus) XXX_Size() int {
	return m.Size()
}
func (m *PartitionResponseStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionResponseStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionResponseStatus proto.InternalMessageInfo

func (m *PartitionResponseStatus) GetCode() PartitionResponseCode {
	if m != nil {
		return m.Code
	}
	return PartitionResponseCode_PARTITION_OK
}

func (m *PartitionResponseStatus) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

type StateMachineWriteRequest struct {
	Request   ServiceWriteRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request"`
	Timestamp time.Time           `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
}

func (m *StateMachineWriteRequest) Reset()         { *m = StateMachineWriteRequest{} }
func (m *StateMachineWriteRequest) String() string { return proto.CompactTextString(m) }
func (*StateMachineWriteRequest) ProtoMessage()    {}
func (*StateMachineWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{16}
}
func (m *StateMachineWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineWriteRequest.Merge(m, src)
}
func (m *StateMachineWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineWriteRequest proto.InternalMessageInfo

func (m *StateMachineWriteRequest) GetRequest() ServiceWriteRequest {
	if m != nil {
		return m.Request
	}
	return ServiceWriteRequest{}
}

func (m *StateMachineWriteRequest) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

type StateMachineWriteResponse struct {
	Response ServiceWriteResponse `protobuf:"bytes,1,opt,name=response,proto3" json:"response"`
}

func (m *StateMachineWriteResponse) Reset()         { *m = StateMachineWriteResponse{} }
func (m *StateMachineWriteResponse) String() string { return proto.CompactTextString(m) }
func (*StateMachineWriteResponse) ProtoMessage()    {}
func (*StateMachineWriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{17}
}
func (m *StateMachineWriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineWriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineWriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineWriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineWriteResponse.Merge(m, src)
}
func (m *StateMachineWriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineWriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineWriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineWriteResponse proto.InternalMessageInfo

func (m *StateMachineWriteResponse) GetResponse() ServiceWriteResponse {
	if m != nil {
		return m.Response
	}
	return ServiceWriteResponse{}
}

type ServiceWriteRequest struct {
	ServiceID ServiceID           `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3,casttype=ServiceID" json:"service_id"`
	Request   SessionWriteRequest `protobuf:"bytes,2,opt,name=request,proto3" json:"request"`
}

func (m *ServiceWriteRequest) Reset()         { *m = ServiceWriteRequest{} }
func (m *ServiceWriteRequest) String() string { return proto.CompactTextString(m) }
func (*ServiceWriteRequest) ProtoMessage()    {}
func (*ServiceWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{18}
}
func (m *ServiceWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceWriteRequest.Merge(m, src)
}
func (m *ServiceWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServiceWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceWriteRequest proto.InternalMessageInfo

func (m *ServiceWriteRequest) GetServiceID() ServiceID {
	if m != nil {
		return m.ServiceID
	}
	return ServiceID{}
}

func (m *ServiceWriteRequest) GetRequest() SessionWriteRequest {
	if m != nil {
		return m.Request
	}
	return SessionWriteRequest{}
}

type ServiceWriteResponse struct {
	Response SessionWriteResponse `protobuf:"bytes,1,opt,name=response,proto3" json:"response"`
}

func (m *ServiceWriteResponse) Reset()         { *m = ServiceWriteResponse{} }
func (m *ServiceWriteResponse) String() string { return proto.CompactTextString(m) }
func (*ServiceWriteResponse) ProtoMessage()    {}
func (*ServiceWriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{19}
}
func (m *ServiceWriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceWriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceWriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceWriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceWriteResponse.Merge(m, src)
}
func (m *ServiceWriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *ServiceWriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceWriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceWriteResponse proto.InternalMessageInfo

func (m *ServiceWriteResponse) GetResponse() SessionWriteResponse {
	if m != nil {
		return m.Response
	}
	return SessionWriteResponse{}
}

type SessionWriteRequest struct {
	SessionID SessionID `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	RequestID RequestID `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*SessionWriteRequest_OpenSession
	//	*SessionWriteRequest_KeepAlive
	//	*SessionWriteRequest_CloseSession
	//	*SessionWriteRequest_Command
	Request isSessionWriteRequest_Request `protobuf_oneof:"request"`
}

func (m *SessionWriteRequest) Reset()         { *m = SessionWriteRequest{} }
func (m *SessionWriteRequest) String() string { return proto.CompactTextString(m) }
func (*SessionWriteRequest) ProtoMessage()    {}
func (*SessionWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{20}
}
func (m *SessionWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionWriteRequest.Merge(m, src)
}
func (m *SessionWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *SessionWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SessionWriteRequest proto.InternalMessageInfo

type isSessionWriteRequest_Request interface {
	isSessionWriteRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionWriteRequest_OpenSession struct {
	OpenSession *OpenSessionRequest `protobuf:"bytes,3,opt,name=open_session,json=openSession,proto3,oneof" json:"open_session,omitempty"`
}
type SessionWriteRequest_KeepAlive struct {
	KeepAlive *KeepAliveRequest `protobuf:"bytes,4,opt,name=keep_alive,json=keepAlive,proto3,oneof" json:"keep_alive,omitempty"`
}
type SessionWriteRequest_CloseSession struct {
	CloseSession *CloseSessionRequest `protobuf:"bytes,5,opt,name=close_session,json=closeSession,proto3,oneof" json:"close_session,omitempty"`
}
type SessionWriteRequest_Command struct {
	Command *CommandRequest `protobuf:"bytes,6,opt,name=command,proto3,oneof" json:"command,omitempty"`
}

func (*SessionWriteRequest_OpenSession) isSessionWriteRequest_Request()  {}
func (*SessionWriteRequest_KeepAlive) isSessionWriteRequest_Request()    {}
func (*SessionWriteRequest_CloseSession) isSessionWriteRequest_Request() {}
func (*SessionWriteRequest_Command) isSessionWriteRequest_Request()      {}

func (m *SessionWriteRequest) GetRequest() isSessionWriteRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SessionWriteRequest) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionWriteRequest) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *SessionWriteRequest) GetOpenSession() *OpenSessionRequest {
	if x, ok := m.GetRequest().(*SessionWriteRequest_OpenSession); ok {
		return x.OpenSession
	}
	return nil
}

func (m *SessionWriteRequest) GetKeepAlive() *KeepAliveRequest {
	if x, ok := m.GetRequest().(*SessionWriteRequest_KeepAlive); ok {
		return x.KeepAlive
	}
	return nil
}

func (m *SessionWriteRequest) GetCloseSession() *CloseSessionRequest {
	if x, ok := m.GetRequest().(*SessionWriteRequest_CloseSession); ok {
		return x.CloseSession
	}
	return nil
}

func (m *SessionWriteRequest) GetCommand() *CommandRequest {
	if x, ok := m.GetRequest().(*SessionWriteRequest_Command); ok {
		return x.Command
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionWriteRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionWriteRequest_OpenSession)(nil),
		(*SessionWriteRequest_KeepAlive)(nil),
		(*SessionWriteRequest_CloseSession)(nil),
		(*SessionWriteRequest_Command)(nil),
	}
}

type SessionWriteResponse struct {
	Type       SessionResponseType   `protobuf:"varint,1,opt,name=type,proto3,enum=atomix.service.SessionResponseType" json:"type,omitempty"`
	Status     SessionResponseStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status"`
	RequestID  RequestID             `protobuf:"varint,3,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	ResponseID ResponseID            `protobuf:"varint,4,opt,name=response_id,json=responseId,proto3,casttype=ResponseID" json:"response_id,omitempty"`
	// Types that are valid to be assigned to Response:
	//	*SessionWriteResponse_OpenSession
	//	*SessionWriteResponse_KeepAlive
	//	*SessionWriteResponse_CloseSession
	//	*SessionWriteResponse_Command
	Response isSessionWriteResponse_Response `protobuf_oneof:"response"`
}

func (m *SessionWriteResponse) Reset()         { *m = SessionWriteResponse{} }
func (m *SessionWriteResponse) String() string { return proto.CompactTextString(m) }
func (*SessionWriteResponse) ProtoMessage()    {}
func (*SessionWriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{21}
}
func (m *SessionWriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionWriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionWriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionWriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionWriteResponse.Merge(m, src)
}
func (m *SessionWriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *SessionWriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionWriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SessionWriteResponse proto.InternalMessageInfo

type isSessionWriteResponse_Response interface {
	isSessionWriteResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionWriteResponse_OpenSession struct {
	OpenSession *OpenSessionResponse `protobuf:"bytes,5,opt,name=open_session,json=openSession,proto3,oneof" json:"open_session,omitempty"`
}
type SessionWriteResponse_KeepAlive struct {
	KeepAlive *KeepAliveResponse `protobuf:"bytes,6,opt,name=keep_alive,json=keepAlive,proto3,oneof" json:"keep_alive,omitempty"`
}
type SessionWriteResponse_CloseSession struct {
	CloseSession *CloseSessionResponse `protobuf:"bytes,7,opt,name=close_session,json=closeSession,proto3,oneof" json:"close_session,omitempty"`
}
type SessionWriteResponse_Command struct {
	Command *CommandResponse `protobuf:"bytes,8,opt,name=command,proto3,oneof" json:"command,omitempty"`
}

func (*SessionWriteResponse_OpenSession) isSessionWriteResponse_Response()  {}
func (*SessionWriteResponse_KeepAlive) isSessionWriteResponse_Response()    {}
func (*SessionWriteResponse_CloseSession) isSessionWriteResponse_Response() {}
func (*SessionWriteResponse_Command) isSessionWriteResponse_Response()      {}

func (m *SessionWriteResponse) GetResponse() isSessionWriteResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SessionWriteResponse) GetType() SessionResponseType {
	if m != nil {
		return m.Type
	}
	return SessionResponseType_RESPONSE
}

func (m *SessionWriteResponse) GetStatus() SessionResponseStatus {
	if m != nil {
		return m.Status
	}
	return SessionResponseStatus{}
}

func (m *SessionWriteResponse) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *SessionWriteResponse) GetResponseID() ResponseID {
	if m != nil {
		return m.ResponseID
	}
	return 0
}

func (m *SessionWriteResponse) GetOpenSession() *OpenSessionResponse {
	if x, ok := m.GetResponse().(*SessionWriteResponse_OpenSession); ok {
		return x.OpenSession
	}
	return nil
}

func (m *SessionWriteResponse) GetKeepAlive() *KeepAliveResponse {
	if x, ok := m.GetResponse().(*SessionWriteResponse_KeepAlive); ok {
		return x.KeepAlive
	}
	return nil
}

func (m *SessionWriteResponse) GetCloseSession() *CloseSessionResponse {
	if x, ok := m.GetResponse().(*SessionWriteResponse_CloseSession); ok {
		return x.CloseSession
	}
	return nil
}

func (m *SessionWriteResponse) GetCommand() *CommandResponse {
	if x, ok := m.GetResponse().(*SessionWriteResponse_Command); ok {
		return x.Command
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionWriteResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionWriteResponse_OpenSession)(nil),
		(*SessionWriteResponse_KeepAlive)(nil),
		(*SessionWriteResponse_CloseSession)(nil),
		(*SessionWriteResponse_Command)(nil),
	}
}

type OpenSessionRequest struct {
	Timeout *time.Duration `protobuf:"bytes,1,opt,name=timeout,proto3,stdduration" json:"timeout,omitempty"`
}

func (m *OpenSessionRequest) Reset()         { *m = OpenSessionRequest{} }
func (m *OpenSessionRequest) String() string { return proto.CompactTextString(m) }
func (*OpenSessionRequest) ProtoMessage()    {}
func (*OpenSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{22}
}
func (m *OpenSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenSessionRequest.Merge(m, src)
}
func (m *OpenSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *OpenSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenSessionRequest proto.InternalMessageInfo

func (m *OpenSessionRequest) GetTimeout() *time.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

type OpenSessionResponse struct {
}

func (m *OpenSessionResponse) Reset()         { *m = OpenSessionResponse{} }
func (m *OpenSessionResponse) String() string { return proto.CompactTextString(m) }
func (*OpenSessionResponse) ProtoMessage()    {}
func (*OpenSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{23}
}
func (m *OpenSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenSessionResponse.Merge(m, src)
}
func (m *OpenSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *OpenSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OpenSessionResponse proto.InternalMessageInfo

type KeepAliveRequest struct {
	AckResponseID ResponseID `protobuf:"varint,1,opt,name=ack_response_id,json=ackResponseId,proto3,casttype=ResponseID" json:"ack_response_id,omitempty"`
}

func (m *KeepAliveRequest) Reset()         { *m = KeepAliveRequest{} }
func (m *KeepAliveRequest) String() string { return proto.CompactTextString(m) }
func (*KeepAliveRequest) ProtoMessage()    {}
func (*KeepAliveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{24}
}
func (m *KeepAliveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeepAliveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeepAliveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeepAliveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeepAliveRequest.Merge(m, src)
}
func (m *KeepAliveRequest) XXX_Size() int {
	return m.Size()
}
func (m *KeepAliveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KeepAliveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KeepAliveRequest proto.InternalMessageInfo

func (m *KeepAliveRequest) GetAckResponseID() ResponseID {
	if m != nil {
		return m.AckResponseID
	}
	return 0
}

type KeepAliveResponse struct {
}

func (m *KeepAliveResponse) Reset()         { *m = KeepAliveResponse{} }
func (m *KeepAliveResponse) String() string { return proto.CompactTextString(m) }
func (*KeepAliveResponse) ProtoMessage()    {}
func (*KeepAliveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{25}
}
func (m *KeepAliveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeepAliveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeepAliveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeepAliveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeepAliveResponse.Merge(m, src)
}
func (m *KeepAliveResponse) XXX_Size() int {
	return m.Size()
}
func (m *KeepAliveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KeepAliveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KeepAliveResponse proto.InternalMessageInfo

type CloseSessionRequest struct {
}

func (m *CloseSessionRequest) Reset()         { *m = CloseSessionRequest{} }
func (m *CloseSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CloseSessionRequest) ProtoMessage()    {}
func (*CloseSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{26}
}
func (m *CloseSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseSessionRequest.Merge(m, src)
}
func (m *CloseSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CloseSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CloseSessionRequest proto.InternalMessageInfo

type CloseSessionResponse struct {
}

func (m *CloseSessionResponse) Reset()         { *m = CloseSessionResponse{} }
func (m *CloseSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CloseSessionResponse) ProtoMessage()    {}
func (*CloseSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{27}
}
func (m *CloseSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseSessionResponse.Merge(m, src)
}
func (m *CloseSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CloseSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CloseSessionResponse proto.InternalMessageInfo

type CommandRequest struct {
	OperationID OperationID `protobuf:"bytes,1,opt,name=operation_id,json=operationId,proto3,casttype=OperationID" json:"operation_id,omitempty"`
	Value       []byte      `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *CommandRequest) Reset()         { *m = CommandRequest{} }
func (m *CommandRequest) String() string { return proto.CompactTextString(m) }
func (*CommandRequest) ProtoMessage()    {}
func (*CommandRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{28}
}
func (m *CommandRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRequest.Merge(m, src)
}
func (m *CommandRequest) XXX_Size() int {
	return m.Size()
}
func (m *CommandRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRequest proto.InternalMessageInfo

func (m *CommandRequest) GetOperationID() OperationID {
	if m != nil {
		return m.OperationID
	}
	return ""
}

func (m *CommandRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CommandResponse struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *CommandResponse) Reset()         { *m = CommandResponse{} }
func (m *CommandResponse) String() string { return proto.CompactTextString(m) }
func (*CommandResponse) ProtoMessage()    {}
func (*CommandResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{29}
}
func (m *CommandResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandResponse.Merge(m, src)
}
func (m *CommandResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommandResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandResponse proto.InternalMessageInfo

func (m *CommandResponse) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

type QueryRequest struct {
	OperationID OperationID `protobuf:"bytes,1,opt,name=operation_id,json=operationId,proto3,casttype=OperationID" json:"operation_id,omitempty"`
	Value       []byte      `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *QueryRequest) Reset()         { *m = QueryRequest{} }
func (m *QueryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()    {}
func (*QueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{30}
}
func (m *QueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRequest.Merge(m, src)
}
func (m *QueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRequest proto.InternalMessageInfo

func (m *QueryRequest) GetOperationID() OperationID {
	if m != nil {
		return m.OperationID
	}
	return ""
}

func (m *QueryRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type QueryResponse struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *QueryResponse) Reset()         { *m = QueryResponse{} }
func (m *QueryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResponse) ProtoMessage()    {}
func (*QueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{31}
}
func (m *QueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResponse.Merge(m, src)
}
func (m *QueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResponse proto.InternalMessageInfo

func (m *QueryResponse) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

type SessionResponseStatus struct {
	Code    SessionResponseCode `protobuf:"varint,1,opt,name=code,proto3,enum=atomix.service.SessionResponseCode" json:"code,omitempty"`
	Message string              `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *SessionResponseStatus) Reset()         { *m = SessionResponseStatus{} }
func (m *SessionResponseStatus) String() string { return proto.CompactTextString(m) }
func (*SessionResponseStatus) ProtoMessage()    {}
func (*SessionResponseStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ac9f0060bc696f, []int{32}
}
func (m *SessionResponseStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionResponseStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionResponseStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionResponseStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionResponseStatus.Merge(m, src)
}
func (m *SessionResponseStatus) XXX_Size() int {
	return m.Size()
}
func (m *SessionResponseStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionResponseStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SessionResponseStatus proto.InternalMessageInfo

func (m *SessionResponseStatus) GetCode() SessionResponseCode {
	if m != nil {
		return m.Code
	}
	return SessionResponseCode_OK
}

func (m *SessionResponseStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("atomix.service.PartitionResponseCode", PartitionResponseCode_name, PartitionResponseCode_value)
	proto.RegisterEnum("atomix.service.SessionResponseType", SessionResponseType_name, SessionResponseType_value)
	proto.RegisterEnum("atomix.service.SessionResponseCode", SessionResponseCode_name, SessionResponseCode_value)
	proto.RegisterType((*StateMachineSnapshot)(nil), "atomix.service.StateMachineSnapshot")
	proto.RegisterType((*ServiceSnapshot)(nil), "atomix.service.ServiceSnapshot")
	proto.RegisterType((*SessionSnapshot)(nil), "atomix.service.SessionSnapshot")
	proto.RegisterType((*SessionStreamSnapshot)(nil), "atomix.service.SessionStreamSnapshot")
	proto.RegisterType((*ServiceId)(nil), "atomix.service.ServiceId")
	proto.RegisterType((*PartitionReadRequest)(nil), "atomix.service.PartitionReadRequest")
	proto.RegisterType((*PartitionReadResponse)(nil), "atomix.service.PartitionReadResponse")
	proto.RegisterType((*StateMachineReadRequest)(nil), "atomix.service.StateMachineReadRequest")
	proto.RegisterType((*StateMachineReadResponse)(nil), "atomix.service.StateMachineReadResponse")
	proto.RegisterType((*ServiceReadRequest)(nil), "atomix.service.ServiceReadRequest")
	proto.RegisterType((*ServiceReadResponse)(nil), "atomix.service.ServiceReadResponse")
	proto.RegisterType((*SessionReadRequest)(nil), "atomix.service.SessionReadRequest")
	proto.RegisterType((*SessionReadResponse)(nil), "atomix.service.SessionReadResponse")
	proto.RegisterType((*PartitionWriteRequest)(nil), "atomix.service.PartitionWriteRequest")
	proto.RegisterType((*PartitionWriteResponse)(nil), "atomix.service.PartitionWriteResponse")
	proto.RegisterType((*PartitionResponseStatus)(nil), "atomix.service.PartitionResponseStatus")
	proto.RegisterType((*StateMachineWriteRequest)(nil), "atomix.service.StateMachineWriteRequest")
	proto.RegisterType((*StateMachineWriteResponse)(nil), "atomix.service.StateMachineWriteResponse")
	proto.RegisterType((*ServiceWriteRequest)(nil), "atomix.service.ServiceWriteRequest")
	proto.RegisterType((*ServiceWriteResponse)(nil), "atomix.service.ServiceWriteResponse")
	proto.RegisterType((*SessionWriteRequest)(nil), "atomix.service.SessionWriteRequest")
	proto.RegisterType((*SessionWriteResponse)(nil), "atomix.service.SessionWriteResponse")
	proto.RegisterType((*OpenSessionRequest)(nil), "atomix.service.OpenSessionRequest")
	proto.RegisterType((*OpenSessionResponse)(nil), "atomix.service.OpenSessionResponse")
	proto.RegisterType((*KeepAliveRequest)(nil), "atomix.service.KeepAliveRequest")
	proto.RegisterType((*KeepAliveResponse)(nil), "atomix.service.KeepAliveResponse")
	proto.RegisterType((*CloseSessionRequest)(nil), "atomix.service.CloseSessionRequest")
	proto.RegisterType((*CloseSessionResponse)(nil), "atomix.service.CloseSessionResponse")
	proto.RegisterType((*CommandRequest)(nil), "atomix.service.CommandRequest")
	proto.RegisterType((*CommandResponse)(nil), "atomix.service.CommandResponse")
	proto.RegisterType((*QueryRequest)(nil), "atomix.service.QueryRequest")
	proto.RegisterType((*QueryResponse)(nil), "atomix.service.QueryResponse")
	proto.RegisterType((*SessionResponseStatus)(nil), "atomix.service.SessionResponseStatus")
}

func init() {
	proto.RegisterFile("atomix/storage/protocol/rsm2/service.proto", fileDescriptor_82ac9f0060bc696f)
}

var fileDescriptor_82ac9f0060bc696f = []byte{
	// 1722 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x4f, 0x73, 0xd3, 0xcc,
	0x19, 0x8f, 0xfc, 0x27, 0xb6, 0x1f, 0xdb, 0x89, 0xd8, 0x04, 0x30, 0x19, 0x6a, 0xa7, 0x2a, 0x29,
	0x69, 0x0e, 0x09, 0x93, 0x96, 0x61, 0x52, 0xa6, 0xd3, 0x91, 0x6d, 0x05, 0x4c, 0x1c, 0x29, 0xac,
	0x1d, 0xa0, 0xa5, 0xad, 0x2b, 0x2c, 0xd5, 0xb8, 0xb1, 0x2d, 0x63, 0xc9, 0x0c, 0x5c, 0xfb, 0x01,
	0x3a, 0xf4, 0xd6, 0x7b, 0xa7, 0xed, 0x4c, 0x8f, 0x4c, 0x0f, 0x7c, 0x04, 0x8e, 0x1c, 0x7b, 0x69,
	0xda, 0xd7, 0x7c, 0x88, 0x77, 0x86, 0xd3, 0x3b, 0xbb, 0x2b, 0xc9, 0xfa, 0x63, 0x25, 0x21, 0x84,
	0x79, 0x4f, 0xd6, 0x3e, 0xfb, 0x3c, 0xbf, 0x7d, 0xfe, 0xed, 0x6f, 0x77, 0x0d, 0x1b, 0xaa, 0x65,
	0xf4, 0xbb, 0xaf, 0xb6, 0x4c, 0xcb, 0x18, 0xa9, 0x1d, 0x7d, 0x6b, 0x38, 0x32, 0x2c, 0xa3, 0x6d,
	0xf4, 0xb6, 0x46, 0x66, 0x7f, 0x7b, 0xcb, 0xd4, 0x47, 0x2f, 0xbb, 0x6d, 0x7d, 0x93, 0x4a, 0xd1,
	0x02, 0xd3, 0xdd, 0xb4, 0xa5, 0x2b, 0xc5, 0x8e, 0x61, 0x74, 0x7a, 0xb6, 0xcd, 0xb3, 0xf1, 0x1f,
	0xb6, 0xb4, 0xf1, 0x48, 0xb5, 0xba, 0xc6, 0x80, 0xe9, 0xaf, 0x94, 0x82, 0xf3, 0x56, 0xb7, 0xaf,
	0x9b, 0x96, 0xda, 0x1f, 0xda, 0x0a, 0xcb, 0x1d, 0xa3, 0x63, 0xd0, 0xcf, 0x2d, 0xf2, 0xc5, 0xa4,
	0xc2, 0x3b, 0x0e, 0x96, 0x1b, 0x96, 0x6a, 0xe9, 0xfb, 0x6a, 0xfb, 0x79, 0x77, 0xa0, 0x37, 0x06,
	0xea, 0xd0, 0x7c, 0x6e, 0x58, 0xa8, 0x04, 0xc9, 0xee, 0x40, 0xd3, 0x5f, 0x15, 0xb8, 0x55, 0x6e,
	0x3d, 0x51, 0xce, 0x7c, 0x3a, 0x2e, 0x25, 0x6b, 0x44, 0x80, 0x99, 0x1c, 0x95, 0x21, 0xe3, 0x2e,
	0x51, 0x88, 0xad, 0x72, 0xeb, 0xd9, 0xed, 0x95, 0x4d, 0xe6, 0xc4, 0xa6, 0xe3, 0xc4, 0x66, 0xd3,
	0xd1, 0x28, 0xa7, 0xdf, 0x1f, 0x97, 0xe6, 0xde, 0xfc, 0xaf, 0xc4, 0xe1, 0xa9, 0x19, 0xba, 0x0b,
	0x69, 0x3b, 0x3e, 0xb3, 0x10, 0x5f, 0x8d, 0xaf, 0x67, 0xb7, 0x4b, 0x9b, 0xfe, 0xb8, 0x37, 0x1b,
	0xec, 0xd7, 0xf1, 0x0b, 0xbb, 0x06, 0xc2, 0x7f, 0x39, 0x58, 0x0c, 0xcc, 0xa2, 0x27, 0x00, 0xf6,
	0x7c, 0xab, 0xab, 0x51, 0xd7, 0xb3, 0xdb, 0xd7, 0x22, 0x20, 0x6b, 0x5a, 0xb9, 0x48, 0x9c, 0x9a,
	0x1c, 0x97, 0x32, 0x8e, 0xa8, 0xfa, 0xc9, 0x3b, 0xc0, 0x19, 0xd3, 0x51, 0x9d, 0xe6, 0x23, 0x16,
	0x91, 0x0f, 0x1a, 0x8b, 0x69, 0x76, 0x8d, 0xc1, 0x09, 0xb1, 0xd0, 0x79, 0x6f, 0x2c, 0xcc, 0x00,
	0x21, 0x48, 0x68, 0xaa, 0xa5, 0x16, 0x12, 0xab, 0xdc, 0x7a, 0x0e, 0xd3, 0x6f, 0xe1, 0x5d, 0x9c,
	0xc4, 0xe7, 0xb3, 0x40, 0x3b, 0x24, 0x3e, 0x2a, 0x72, 0xe2, 0x4b, 0x94, 0x57, 0x58, 0x00, 0x54,
	0xea, 0x04, 0x60, 0x0f, 0x48, 0x00, 0xec, 0x53, 0xbb, 0x90, 0x7a, 0xed, 0xc2, 0x62, 0x4f, 0x35,
	0xad, 0xd6, 0x48, 0x7f, 0x31, 0xd6, 0x4d, 0x8b, 0xf8, 0x10, 0xa7, 0x3e, 0x14, 0x27, 0xc7, 0xa5,
	0x7c, 0x5d, 0x35, 0x2d, 0xcc, 0x66, 0x98, 0x1f, 0xee, 0x00, 0xe7, 0x7b, 0x9e, 0x39, 0x0d, 0x3d,
	0x00, 0xde, 0xc6, 0x31, 0x87, 0xc6, 0xc0, 0xa4, 0xc5, 0x4a, 0x50, 0xa0, 0xd5, 0xc9, 0x71, 0x69,
	0x81, 0x01, 0xb1, 0x29, 0x8a, 0x04, 0xd3, 0x11, 0x5e, 0xe8, 0x79, 0x67, 0x35, 0xf4, 0x10, 0x2e,
	0x0d, 0xf5, 0x81, 0xd6, 0x1d, 0x74, 0x5c, 0x38, 0xb3, 0x90, 0xa4, 0x05, 0xb8, 0x11, 0x51, 0x80,
	0xc7, 0xa3, 0xae, 0xa5, 0x3b, 0x10, 0x98, 0xb7, 0xcd, 0x1d, 0x81, 0x89, 0x7e, 0x09, 0x29, 0xd3,
	0x1a, 0xe9, 0x6a, 0xdf, 0x2c, 0xcc, 0x53, 0xa0, 0xb5, 0xa8, 0x4a, 0x52, 0x2d, 0xb7, 0x9e, 0x8e,
	0x95, 0xf0, 0x17, 0x0e, 0x2e, 0xcf, 0x54, 0x41, 0xb7, 0x21, 0xc3, 0x94, 0xa6, 0xf5, 0x2b, 0x4c,
	0x8e, 0x4b, 0x69, 0xa6, 0x46, 0x83, 0x75, 0xbf, 0x71, 0x9a, 0xa9, 0xd6, 0x34, 0x24, 0x42, 0xce,
	0x18, 0xea, 0x6c, 0xc3, 0x3b, 0x59, 0xcf, 0xd0, 0xac, 0x67, 0x15, 0x47, 0x4e, 0x8d, 0xbd, 0x43,
	0x9c, 0x75, 0x6d, 0x6a, 0x9a, 0xb0, 0x0f, 0x6e, 0x63, 0x6b, 0xa4, 0xdf, 0xac, 0xd7, 0x43, 0x9d,
	0x7a, 0x90, 0xc1, 0xf4, 0x1b, 0x15, 0x20, 0xd5, 0xee, 0x8d, 0x4d, 0x4b, 0x1f, 0xd1, 0xf6, 0xc8,
	0x60, 0x67, 0x48, 0xb4, 0x07, 0x6a, 0x5f, 0x67, 0xab, 0x62, 0xfa, 0x2d, 0xfc, 0x99, 0x83, 0xe5,
	0x03, 0x75, 0x64, 0x75, 0x09, 0x3c, 0xd6, 0x55, 0xcd, 0xae, 0x2e, 0xda, 0x86, 0xdc, 0xd0, 0x91,
	0x3b, 0x41, 0xe6, 0xcb, 0x8b, 0xc4, 0x55, 0x57, 0x9f, 0xf8, 0xe6, 0x2a, 0xd1, 0xde, 0x4c, 0xd9,
	0x2d, 0x65, 0x77, 0xa6, 0x10, 0xb1, 0x67, 0x3d, 0x0b, 0x95, 0x13, 0xa4, 0x43, 0xb1, 0x63, 0x28,
	0xfc, 0x9d, 0x83, 0xcb, 0x01, 0x87, 0x58, 0x3d, 0x91, 0x04, 0xf3, 0xa6, 0xa5, 0x5a, 0x63, 0xd3,
	0x26, 0x84, 0x9b, 0x41, 0x70, 0x8f, 0x19, 0x33, 0x69, 0x50, 0x75, 0x7b, 0x05, 0xdb, 0x18, 0x49,
	0x90, 0x76, 0x1a, 0xcc, 0xf6, 0xf2, 0x47, 0x27, 0x7a, 0xc9, 0x54, 0x6d, 0x10, 0xd7, 0x54, 0xf8,
	0x2d, 0x5c, 0xf5, 0x12, 0xae, 0x37, 0x75, 0x9e, 0x34, 0x70, 0xe7, 0x4d, 0x83, 0x0a, 0x85, 0x30,
	0xbc, 0x9b, 0x88, 0x69, 0x04, 0xdc, 0xf9, 0x23, 0x78, 0xcb, 0x01, 0x0a, 0x3b, 0xf2, 0x15, 0xb9,
	0xf7, 0x2c, 0xed, 0x41, 0x37, 0xdb, 0x09, 0x79, 0xf9, 0x0d, 0x2c, 0xcd, 0x88, 0xed, 0x6c, 0x29,
	0xf1, 0x60, 0x47, 0xa4, 0xe4, 0x4f, 0x31, 0x92, 0x92, 0xa0, 0x0f, 0x5f, 0x42, 0xd7, 0x33, 0xa8,
	0x36, 0x76, 0x1e, 0xaa, 0x5d, 0x07, 0xa0, 0x38, 0xec, 0xf0, 0x8a, 0x07, 0x0f, 0xaf, 0x0c, 0x99,
	0xa4, 0x9f, 0xe8, 0x67, 0x90, 0x7c, 0x31, 0xd6, 0x47, 0xaf, 0x29, 0x13, 0x67, 0xb7, 0xaf, 0x07,
	0xf3, 0xf0, 0x90, 0x4c, 0xda, 0xc0, 0xf7, 0xe7, 0x30, 0x53, 0x2e, 0x67, 0xdc, 0xda, 0x08, 0xdf,
	0x72, 0x24, 0xc7, 0xa1, 0x64, 0xa1, 0x3b, 0x1e, 0xb2, 0x59, 0x38, 0x21, 0xbf, 0x4c, 0xbd, 0xf9,
	0x7a, 0xa8, 0xdb, 0x8c, 0x54, 0x71, 0x37, 0x2e, 0x2b, 0xfb, 0xda, 0x29, 0xa6, 0x33, 0xb7, 0xad,
	0x7b, 0x70, 0xc7, 0x23, 0x0e, 0xee, 0xdb, 0xfe, 0xb8, 0x7f, 0x10, 0x11, 0x37, 0x5b, 0x62, 0x1a,
	0x38, 0x4c, 0x3b, 0x47, 0x78, 0xe3, 0xe5, 0x1e, 0xfb, 0x74, 0x39, 0x3f, 0x1b, 0x56, 0x82, 0xed,
	0x1e, 0xb5, 0x4b, 0xbd, 0x2b, 0x05, 0xfb, 0xfd, 0x9f, 0x1c, 0x5c, 0x09, 0xba, 0x74, 0xb1, 0x7c,
	0xb8, 0x1b, 0xe2, 0xc3, 0x1b, 0x27, 0xfb, 0x19, 0xb1, 0x77, 0x7a, 0x70, 0x35, 0x62, 0x41, 0xb4,
	0x03, 0x89, 0xb6, 0xa1, 0x39, 0x9d, 0xb3, 0x76, 0xaa, 0x9f, 0x15, 0x43, 0xd3, 0x31, 0x35, 0x41,
	0x57, 0x60, 0xbe, 0xa7, 0xab, 0x9a, 0x7b, 0x98, 0xd9, 0x23, 0xe1, 0x6f, 0x9c, 0x9f, 0x20, 0x7d,
	0xd5, 0xaa, 0x04, 0x09, 0xf8, 0x1c, 0x99, 0xbf, 0x88, 0x8b, 0x96, 0xd0, 0x86, 0x6b, 0x33, 0x9c,
	0xb4, 0xeb, 0xb7, 0x1b, 0xe2, 0xac, 0xf3, 0x25, 0xfe, 0xdf, 0x9c, 0xcb, 0x89, 0xbe, 0x2c, 0x7c,
	0x3d, 0x22, 0x3f, 0x4b, 0x67, 0x7b, 0x6f, 0x68, 0x33, 0x3b, 0xfb, 0x77, 0xb0, 0x3c, 0x2b, 0xbc,
	0xb3, 0xa5, 0x25, 0x7c, 0xff, 0x0b, 0xa5, 0xe5, 0x5f, 0x71, 0x97, 0xc6, 0x7c, 0x69, 0xf9, 0x02,
	0x32, 0xdf, 0x01, 0x08, 0xf1, 0x38, 0x35, 0x8d, 0xe0, 0xf0, 0xcc, 0xc8, 0xe5, 0xef, 0x7b, 0xf4,
	0xe6, 0x37, 0x68, 0xd9, 0x60, 0x94, 0xc5, 0x66, 0x1c, 0x80, 0xca, 0x50, 0x1f, 0xb8, 0x6c, 0xe8,
	0x50, 0x34, 0xb9, 0xff, 0x39, 0x52, 0x24, 0x02, 0x1c, 0xe9, 0xfa, 0xb0, 0xa5, 0xf6, 0xba, 0x2f,
	0x75, 0x9b, 0xeb, 0x56, 0x83, 0x30, 0x7b, 0xba, 0x3e, 0x14, 0x89, 0xc2, 0x14, 0x24, 0x73, 0xe4,
	0xc8, 0xd0, 0x03, 0xc8, 0xb7, 0x7b, 0x86, 0xa9, 0xbb, 0xce, 0x24, 0x67, 0x17, 0xb1, 0x42, 0x94,
	0x42, 0xde, 0xe4, 0xda, 0x1e, 0x31, 0xfa, 0x39, 0xa4, 0xda, 0x46, 0xbf, 0xaf, 0x0e, 0xb4, 0xc2,
	0x3c, 0x45, 0x29, 0x86, 0x50, 0xd8, 0xf4, 0x14, 0xc0, 0x31, 0xf0, 0x9e, 0x39, 0x6f, 0x13, 0xa4,
	0x1b, 0xc2, 0x55, 0xfd, 0x9e, 0x0f, 0x1d, 0x7f, 0xc1, 0xe3, 0x9f, 0x53, 0xf0, 0x5f, 0x40, 0x36,
	0xfc, 0x2c, 0xba, 0x3e, 0xf1, 0x3d, 0x82, 0x02, 0x4f, 0x22, 0x18, 0x4d, 0x9f, 0x43, 0xf7, 0x03,
	0xfd, 0x12, 0x51, 0x22, 0x5f, 0xbf, 0xb8, 0x47, 0x9b, 0xaf, 0x61, 0xca, 0xbe, 0x86, 0x61, 0x45,
	0xfa, 0xe1, 0x09, 0x0d, 0xe3, 0xa2, 0x78, 0x3a, 0x66, 0x2f, 0xd8, 0x31, 0xa9, 0xd9, 0x1b, 0xd3,
	0xdf, 0x31, 0x2e, 0x92, 0xbf, 0x65, 0xee, 0x4e, 0x5b, 0x26, 0x4d, 0x61, 0x4a, 0x91, 0x2d, 0xe3,
	0x22, 0xb8, 0x3d, 0xe3, 0x3d, 0xae, 0x15, 0x40, 0xe1, 0xfd, 0x82, 0x76, 0x20, 0x45, 0x08, 0xd8,
	0x18, 0x5b, 0x2e, 0xe7, 0x05, 0x59, 0xbb, 0x6a, 0xff, 0xe7, 0x52, 0x4e, 0xfc, 0x95, 0x10, 0xb6,
	0xa3, 0x2f, 0x5c, 0x86, 0xa5, 0x19, 0x09, 0x15, 0x9e, 0x02, 0x1f, 0xdc, 0x50, 0xe8, 0x1e, 0x2c,
	0xaa, 0xed, 0x23, 0xdf, 0xcb, 0x97, 0x51, 0x49, 0x89, 0xdc, 0xeb, 0xc4, 0xf6, 0x51, 0x64, 0x95,
	0xf3, 0xaa, 0x67, 0x52, 0x13, 0x96, 0xe0, 0x52, 0x28, 0xf9, 0xc4, 0x91, 0x19, 0x9b, 0x4f, 0xb8,
	0x02, 0xcb, 0xb3, 0x32, 0x2c, 0x74, 0x61, 0xc1, 0xbf, 0xcb, 0x42, 0x0f, 0x4d, 0xee, 0xb3, 0x1f,
	0x9a, 0x68, 0x19, 0x92, 0x2f, 0xd5, 0xde, 0x98, 0x5d, 0x0a, 0x72, 0x98, 0x0d, 0x84, 0x9f, 0xc0,
	0x62, 0xa0, 0x3a, 0xe4, 0x88, 0x1e, 0xe9, 0xe6, 0xb8, 0xc7, 0xf2, 0x9d, 0xc3, 0xf6, 0x48, 0xe8,
	0x40, 0xce, 0x7b, 0xd7, 0xfc, 0x7a, 0x3e, 0xdd, 0x84, 0xbc, 0xef, 0x72, 0x17, 0xe9, 0xd1, 0x1f,
	0xdd, 0xe7, 0x7c, 0xe0, 0x82, 0x72, 0xc7, 0x77, 0x41, 0x39, 0x8d, 0x65, 0x3c, 0xd7, 0x93, 0x02,
	0xa4, 0xfa, 0xba, 0x69, 0xaa, 0x1d, 0xdd, 0x79, 0x6c, 0xdb, 0xc3, 0x8d, 0x27, 0xbe, 0x67, 0xec,
	0xd4, 0x10, 0xf1, 0x90, 0x3b, 0x10, 0x71, 0xb3, 0xd6, 0xac, 0x29, 0x72, 0x4b, 0xd9, 0xe3, 0xe7,
	0xd0, 0x12, 0x2c, 0x4e, 0x25, 0x12, 0xc6, 0x0a, 0xe6, 0x39, 0x54, 0x80, 0xe5, 0xa9, 0x50, 0x56,
	0x9a, 0xad, 0xba, 0x24, 0x56, 0x25, 0xcc, 0xc7, 0x36, 0x9e, 0x7a, 0xae, 0xe7, 0x53, 0xda, 0x43,
	0x39, 0x48, 0x63, 0xa9, 0x71, 0xa0, 0xc8, 0x0d, 0x89, 0x9f, 0x43, 0x8b, 0x90, 0x6d, 0x34, 0xb1,
	0x24, 0xee, 0xb7, 0x94, 0x03, 0x49, 0xe6, 0x39, 0xb2, 0x88, 0x2d, 0x70, 0xb5, 0x62, 0xc4, 0x17,
	0x5b, 0x58, 0xa9, 0x2b, 0x0d, 0x89, 0x8f, 0x6f, 0x7c, 0xc3, 0x85, 0xd0, 0xa9, 0xd7, 0xf3, 0x10,
	0xa3, 0xbe, 0x66, 0x20, 0xe9, 0x78, 0x98, 0x85, 0xd4, 0xa1, 0xbc, 0x27, 0x2b, 0x8f, 0x65, 0x3e,
	0x46, 0x56, 0xaf, 0x88, 0x72, 0x45, 0xaa, 0x4b, 0x55, 0x3e, 0x8e, 0xf2, 0x90, 0x21, 0x2e, 0xef,
	0x2a, 0x87, 0x72, 0x95, 0x4f, 0x20, 0x04, 0x0b, 0x62, 0x1d, 0x4b, 0x62, 0xf5, 0x57, 0x2d, 0xe9,
	0x49, 0xad, 0xd1, 0x6c, 0xf0, 0x49, 0xb2, 0xf4, 0xa1, 0x2c, 0x1e, 0x36, 0xef, 0x2b, 0xb8, 0xf6,
	0x6b, 0xa9, 0xca, 0xcf, 0x13, 0xa3, 0x5d, 0x05, 0x97, 0x6b, 0xd5, 0xaa, 0x24, 0xf3, 0x29, 0x8a,
	0xa8, 0xc8, 0xbb, 0xf5, 0x5a, 0xa5, 0xc9, 0xa7, 0xc9, 0x62, 0x35, 0xf9, 0x91, 0x58, 0xaf, 0x55,
	0xf9, 0x0c, 0x09, 0xee, 0x50, 0x16, 0x1f, 0x89, 0xb5, 0xba, 0x58, 0xae, 0x4b, 0x3c, 0xa0, 0x4b,
	0x90, 0x27, 0xeb, 0x35, 0x0e, 0x0f, 0x0e, 0x14, 0xdc, 0x94, 0xaa, 0x7c, 0x96, 0x18, 0x34, 0x6b,
	0xfb, 0x92, 0x72, 0xd8, 0xe4, 0x73, 0x04, 0xab, 0x26, 0x37, 0x25, 0x2c, 0x8b, 0x75, 0x3e, 0xbf,
	0xfd, 0x8f, 0x18, 0xf0, 0x6e, 0x6d, 0xec, 0x3b, 0x08, 0x6a, 0x40, 0x82, 0xbc, 0x76, 0xd0, 0x8d,
	0x13, 0x6e, 0xa7, 0xee, 0x8b, 0x70, 0x65, 0xed, 0x14, 0x2d, 0xbb, 0x11, 0x9f, 0x02, 0x90, 0x31,
	0xfb, 0x27, 0xe8, 0x42, 0xa1, 0x6f, 0x71, 0xe8, 0xf7, 0x90, 0xa5, 0x67, 0xa5, 0x8d, 0x1e, 0x6d,
	0xe7, 0xbd, 0xfe, 0xac, 0xfc, 0xf8, 0x34, 0x35, 0x86, 0xbf, 0xce, 0xdd, 0xe2, 0xca, 0x85, 0xf7,
	0x93, 0x22, 0xf7, 0x61, 0x52, 0xe4, 0xfe, 0x3f, 0x29, 0x72, 0x6f, 0x3e, 0x16, 0xe7, 0x3e, 0x7c,
	0x2c, 0xce, 0xfd, 0xe7, 0x63, 0x71, 0xee, 0xd9, 0x3c, 0xe5, 0xd2, 0x9f, 0x7e, 0x17, 0x00, 0x00,
	0xff, 0xff, 0xd0, 0x66, 0x63, 0x0d, 0x0b, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PartitionServiceClient is the client API for PartitionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PartitionServiceClient interface {
	Read(ctx context.Context, in *PartitionReadRequest, opts ...grpc.CallOption) (*PartitionReadResponse, error)
	ReadStream(ctx context.Context, in *PartitionReadRequest, opts ...grpc.CallOption) (PartitionService_ReadStreamClient, error)
	WriteStream(ctx context.Context, opts ...grpc.CallOption) (PartitionService_WriteStreamClient, error)
}

type partitionServiceClient struct {
	cc *grpc.ClientConn
}

func NewPartitionServiceClient(cc *grpc.ClientConn) PartitionServiceClient {
	return &partitionServiceClient{cc}
}

func (c *partitionServiceClient) Read(ctx context.Context, in *PartitionReadRequest, opts ...grpc.CallOption) (*PartitionReadResponse, error) {
	out := new(PartitionReadResponse)
	err := c.cc.Invoke(ctx, "/atomix.service.PartitionService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *partitionServiceClient) ReadStream(ctx context.Context, in *PartitionReadRequest, opts ...grpc.CallOption) (PartitionService_ReadStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PartitionService_serviceDesc.Streams[0], "/atomix.service.PartitionService/ReadStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &partitionServiceReadStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PartitionService_ReadStreamClient interface {
	Recv() (*PartitionReadResponse, error)
	grpc.ClientStream
}

type partitionServiceReadStreamClient struct {
	grpc.ClientStream
}

func (x *partitionServiceReadStreamClient) Recv() (*PartitionReadResponse, error) {
	m := new(PartitionReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *partitionServiceClient) WriteStream(ctx context.Context, opts ...grpc.CallOption) (PartitionService_WriteStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PartitionService_serviceDesc.Streams[1], "/atomix.service.PartitionService/WriteStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &partitionServiceWriteStreamClient{stream}
	return x, nil
}

type PartitionService_WriteStreamClient interface {
	Send(*PartitionWriteRequest) error
	Recv() (*PartitionWriteResponse, error)
	grpc.ClientStream
}

type partitionServiceWriteStreamClient struct {
	grpc.ClientStream
}

func (x *partitionServiceWriteStreamClient) Send(m *PartitionWriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *partitionServiceWriteStreamClient) Recv() (*PartitionWriteResponse, error) {
	m := new(PartitionWriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PartitionServiceServer is the server API for PartitionService service.
type PartitionServiceServer interface {
	Read(context.Context, *PartitionReadRequest) (*PartitionReadResponse, error)
	ReadStream(*PartitionReadRequest, PartitionService_ReadStreamServer) error
	WriteStream(PartitionService_WriteStreamServer) error
}

// UnimplementedPartitionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedPartitionServiceServer struct {
}

func (*UnimplementedPartitionServiceServer) Read(ctx context.Context, req *PartitionReadRequest) (*PartitionReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedPartitionServiceServer) ReadStream(req *PartitionReadRequest, srv PartitionService_ReadStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadStream not implemented")
}
func (*UnimplementedPartitionServiceServer) WriteStream(srv PartitionService_WriteStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteStream not implemented")
}

func RegisterPartitionServiceServer(s *grpc.Server, srv PartitionServiceServer) {
	s.RegisterService(&_PartitionService_serviceDesc, srv)
}

func _PartitionService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartitionReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.service.PartitionService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).Read(ctx, req.(*PartitionReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PartitionService_ReadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PartitionReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PartitionServiceServer).ReadStream(m, &partitionServiceReadStreamServer{stream})
}

type PartitionService_ReadStreamServer interface {
	Send(*PartitionReadResponse) error
	grpc.ServerStream
}

type partitionServiceReadStreamServer struct {
	grpc.ServerStream
}

func (x *partitionServiceReadStreamServer) Send(m *PartitionReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PartitionService_WriteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PartitionServiceServer).WriteStream(&partitionServiceWriteStreamServer{stream})
}

type PartitionService_WriteStreamServer interface {
	Send(*PartitionWriteResponse) error
	Recv() (*PartitionWriteRequest, error)
	grpc.ServerStream
}

type partitionServiceWriteStreamServer struct {
	grpc.ServerStream
}

func (x *partitionServiceWriteStreamServer) Send(m *PartitionWriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *partitionServiceWriteStreamServer) Recv() (*PartitionWriteRequest, error) {
	m := new(PartitionWriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _PartitionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "atomix.service.PartitionService",
	HandlerType: (*PartitionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _PartitionService_Read_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadStream",
			Handler:       _PartitionService_ReadStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WriteStream",
			Handler:       _PartitionService_WriteStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "atomix/storage/protocol/rsm2/service.proto",
}

func (m *StateMachineSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintService(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x12
	if m.Index != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintService(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Index != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ServiceID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SessionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Streams) > 0 {
		for iNdEx := len(m.Streams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Streams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PendingResponses) > 0 {
		for iNdEx := len(m.PendingResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.LastResponseID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.LastResponseID))
		i--
		dAtA[i] = 0x20
	}
	if m.LastRequestID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.LastRequestID))
		i--
		dAtA[i] = 0x18
	}
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintService(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x12
	if m.SessionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionStreamSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionStreamSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionStreamSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperationID) > 0 {
		i -= len(m.OperationID)
		copy(dAtA[i:], m.OperationID)
		i = encodeVarintService(dAtA, i, uint64(len(m.OperationID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.StreamID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.StreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintService(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintService(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PartitionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StateMachineReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StateMachineReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ServiceReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ServiceID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ServiceReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SessionReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LastIndex != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.LastIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.LastRequestID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.LastRequestID))
		i--
		dAtA[i] = 0x10
	}
	if m.SessionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionReadRequest_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionReadRequest_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SessionReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Index != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionReadResponse_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionReadResponse_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PartitionWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionWriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PartitionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionWriteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PartitionResponseStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionResponseStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionResponseStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintService(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineWriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n18, err18 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err18 != nil {
		return 0, err18
	}
	i -= n18
	i = encodeVarintService(dAtA, i, uint64(n18))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StateMachineWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineWriteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ServiceWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceWriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ServiceID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ServiceWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceWriteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SessionWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RequestID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x10
	}
	if m.SessionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionWriteRequest_OpenSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteRequest_OpenSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpenSession != nil {
		{
			size, err := m.OpenSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SessionWriteRequest_KeepAlive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteRequest_KeepAlive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeepAlive != nil {
		{
			size, err := m.KeepAlive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SessionWriteRequest_CloseSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteRequest_CloseSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloseSession != nil {
		{
			size, err := m.CloseSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SessionWriteRequest_Command) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteRequest_Command) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Command != nil {
		{
			size, err := m.Command.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SessionWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ResponseID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.ResponseID))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionWriteResponse_OpenSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteResponse_OpenSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpenSession != nil {
		{
			size, err := m.OpenSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SessionWriteResponse_KeepAlive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteResponse_KeepAlive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeepAlive != nil {
		{
			size, err := m.KeepAlive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SessionWriteResponse_CloseSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteResponse_CloseSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloseSession != nil {
		{
			size, err := m.CloseSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *SessionWriteResponse_Command) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionWriteResponse_Command) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Command != nil {
		{
			size, err := m.Command.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *OpenSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != nil {
		n33, err33 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout):])
		if err33 != nil {
			return 0, err33
		}
		i -= n33
		i = encodeVarintService(dAtA, i, uint64(n33))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *KeepAliveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeepAliveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeepAliveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AckResponseID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.AckResponseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeepAliveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeepAliveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeepAliveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CloseSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CloseSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CommandRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintService(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OperationID) > 0 {
		i -= len(m.OperationID)
		copy(dAtA[i:], m.OperationID)
		i = encodeVarintService(dAtA, i, uint64(len(m.OperationID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintService(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintService(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OperationID) > 0 {
		i -= len(m.OperationID)
		copy(dAtA[i:], m.OperationID)
		i = encodeVarintService(dAtA, i, uint64(len(m.OperationID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintService(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionResponseStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionResponseStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionResponseStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintService(dAtA []byte, offset int, v uint64) int {
	offset -= sovService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StateMachineSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovService(uint64(m.Index))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovService(uint64(l))
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *ServiceSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ServiceID.Size()
	n += 1 + l + sovService(uint64(l))
	if m.Index != 0 {
		n += 1 + sovService(uint64(m.Index))
	}
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *SessionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovService(uint64(m.SessionID))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovService(uint64(l))
	if m.LastRequestID != 0 {
		n += 1 + sovService(uint64(m.LastRequestID))
	}
	if m.LastResponseID != 0 {
		n += 1 + sovService(uint64(m.LastResponseID))
	}
	if len(m.PendingResponses) > 0 {
		for _, e := range m.PendingResponses {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *SessionStreamSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamID != 0 {
		n += 1 + sovService(uint64(m.StreamID))
	}
	l = len(m.OperationID)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *ServiceId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *PartitionReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionID != 0 {
		n += 1 + sovService(uint64(m.PartitionID))
	}
	l = m.Request.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *PartitionReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Status.Size()
	n += 1 + l + sovService(uint64(l))
	l = m.Response.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *StateMachineReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Request.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *StateMachineReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Response.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *ServiceReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ServiceID.Size()
	n += 1 + l + sovService(uint64(l))
	l = m.Request.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *ServiceReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Response.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *SessionReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovService(uint64(m.SessionID))
	}
	if m.LastRequestID != 0 {
		n += 1 + sovService(uint64(m.LastRequestID))
	}
	if m.LastIndex != 0 {
		n += 1 + sovService(uint64(m.LastIndex))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *SessionReadRequest_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovService(uint64(m.Type))
	}
	l = m.Status.Size()
	n += 1 + l + sovService(uint64(l))
	if m.Index != 0 {
		n += 1 + sovService(uint64(m.Index))
	}
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *SessionReadResponse_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *PartitionWriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionID != 0 {
		n += 1 + sovService(uint64(m.PartitionID))
	}
	l = m.Request.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *PartitionWriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Status.Size()
	n += 1 + l + sovService(uint64(l))
	l = m.Response.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *PartitionResponseStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovService(uint64(m.Code))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *StateMachineWriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Request.Size()
	n += 1 + l + sovService(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *StateMachineWriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Response.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *ServiceWriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ServiceID.Size()
	n += 1 + l + sovService(uint64(l))
	l = m.Request.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *ServiceWriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Response.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *SessionWriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovService(uint64(m.SessionID))
	}
	if m.RequestID != 0 {
		n += 1 + sovService(uint64(m.RequestID))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *SessionWriteRequest_OpenSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenSession != nil {
		l = m.OpenSession.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionWriteRequest_KeepAlive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeepAlive != nil {
		l = m.KeepAlive.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionWriteRequest_CloseSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloseSession != nil {
		l = m.CloseSession.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionWriteRequest_Command) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionWriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovService(uint64(m.Type))
	}
	l = m.Status.Size()
	n += 1 + l + sovService(uint64(l))
	if m.RequestID != 0 {
		n += 1 + sovService(uint64(m.RequestID))
	}
	if m.ResponseID != 0 {
		n += 1 + sovService(uint64(m.ResponseID))
	}
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *SessionWriteResponse_OpenSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenSession != nil {
		l = m.OpenSession.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionWriteResponse_KeepAlive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeepAlive != nil {
		l = m.KeepAlive.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionWriteResponse_CloseSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloseSession != nil {
		l = m.CloseSession.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionWriteResponse_Command) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *OpenSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout)
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *OpenSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *KeepAliveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AckResponseID != 0 {
		n += 1 + sovService(uint64(m.AckResponseID))
	}
	return n
}

func (m *KeepAliveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CloseSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CloseSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CommandRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperationID)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *CommandResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *QueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperationID)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *QueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *SessionResponseStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func sovService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozService(x uint64) (n int) {
	return sovService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StateMachineSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &ServiceSnapshot{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &SessionSnapshot{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRequestID", wireType)
			}
			m.LastRequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastResponseID", wireType)
			}
			m.LastResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastResponseID |= ResponseID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingResponses = append(m.PendingResponses, &SessionWriteResponse{})
			if err := m.PendingResponses[len(m.PendingResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, &SessionStreamSnapshot{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionStreamSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionStreamSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionStreamSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= StreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationID = OperationID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRequestID", wireType)
			}
			m.LastRequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastIndex", wireType)
			}
			m.LastIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastIndex |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SessionReadRequest_Query{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SessionResponseType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SessionReadResponse_Query{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionResponseStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionResponseStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionResponseStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= PartitionResponseCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OpenSessionRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SessionWriteRequest_OpenSession{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KeepAliveRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SessionWriteRequest_KeepAlive{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloseSessionRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SessionWriteRequest_CloseSession{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SessionWriteRequest_Command{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SessionResponseType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseID", wireType)
			}
			m.ResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseID |= ResponseID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OpenSessionResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SessionWriteResponse_OpenSession{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KeepAliveResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SessionWriteResponse_KeepAlive{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloseSessionResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SessionWriteResponse_CloseSession{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SessionWriteResponse_Command{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeepAliveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeepAliveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeepAliveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckResponseID", wireType)
			}
			m.AckResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckResponseID |= ResponseID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeepAliveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeepAliveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeepAliveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationID = OperationID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationID = OperationID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionResponseStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionResponseStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionResponseStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= SessionResponseCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupService = fmt.Errorf("proto: unexpected end of group")
)
