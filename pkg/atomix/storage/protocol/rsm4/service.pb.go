// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: atomix/storage/protocol/rsm4/service.proto

package rsm

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ResponseCode int32

const (
	ResponseCode_OK             ResponseCode = 0
	ResponseCode_ERROR          ResponseCode = 1
	ResponseCode_UNKNOWN        ResponseCode = 2
	ResponseCode_CANCELED       ResponseCode = 3
	ResponseCode_NOT_FOUND      ResponseCode = 4
	ResponseCode_ALREADY_EXISTS ResponseCode = 5
	ResponseCode_UNAUTHORIZED   ResponseCode = 6
	ResponseCode_FORBIDDEN      ResponseCode = 7
	ResponseCode_CONFLICT       ResponseCode = 8
	ResponseCode_INVALID        ResponseCode = 9
	ResponseCode_UNAVAILABLE    ResponseCode = 10
	ResponseCode_NOT_SUPPORTED  ResponseCode = 11
	ResponseCode_TIMEOUT        ResponseCode = 12
	ResponseCode_INTERNAL       ResponseCode = 13
)

var ResponseCode_name = map[int32]string{
	0:  "OK",
	1:  "ERROR",
	2:  "UNKNOWN",
	3:  "CANCELED",
	4:  "NOT_FOUND",
	5:  "ALREADY_EXISTS",
	6:  "UNAUTHORIZED",
	7:  "FORBIDDEN",
	8:  "CONFLICT",
	9:  "INVALID",
	10: "UNAVAILABLE",
	11: "NOT_SUPPORTED",
	12: "TIMEOUT",
	13: "INTERNAL",
}

var ResponseCode_value = map[string]int32{
	"OK":             0,
	"ERROR":          1,
	"UNKNOWN":        2,
	"CANCELED":       3,
	"NOT_FOUND":      4,
	"ALREADY_EXISTS": 5,
	"UNAUTHORIZED":   6,
	"FORBIDDEN":      7,
	"CONFLICT":       8,
	"INVALID":        9,
	"UNAVAILABLE":    10,
	"NOT_SUPPORTED":  11,
	"TIMEOUT":        12,
	"INTERNAL":       13,
}

func (x ResponseCode) String() string {
	return proto.EnumName(ResponseCode_name, int32(x))
}

func (ResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{0}
}

type StateMachineSnapshot struct {
	Index     Index              `protobuf:"varint,1,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	Timestamp time.Time          `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Clients   []*ClientSnapshot  `protobuf:"bytes,3,rep,name=clients,proto3" json:"clients,omitempty"`
	Services  []*ServiceSnapshot `protobuf:"bytes,4,rep,name=services,proto3" json:"services,omitempty"`
}

func (m *StateMachineSnapshot) Reset()         { *m = StateMachineSnapshot{} }
func (m *StateMachineSnapshot) String() string { return proto.CompactTextString(m) }
func (*StateMachineSnapshot) ProtoMessage()    {}
func (*StateMachineSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{0}
}
func (m *StateMachineSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineSnapshot.Merge(m, src)
}
func (m *StateMachineSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineSnapshot proto.InternalMessageInfo

func (m *StateMachineSnapshot) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StateMachineSnapshot) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *StateMachineSnapshot) GetClients() []*ClientSnapshot {
	if m != nil {
		return m.Clients
	}
	return nil
}

func (m *StateMachineSnapshot) GetServices() []*ServiceSnapshot {
	if m != nil {
		return m.Services
	}
	return nil
}

type ClientSnapshot struct {
	ClientID       ClientID           `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3,casttype=ClientID" json:"client_id,omitempty"`
	SessionTimeout time.Duration      `protobuf:"bytes,2,opt,name=session_timeout,json=sessionTimeout,proto3,stdduration" json:"session_timeout"`
	LastUpdated    time.Time          `protobuf:"bytes,3,opt,name=last_updated,json=lastUpdated,proto3,stdtime" json:"last_updated"`
	Sessions       []*SessionSnapshot `protobuf:"bytes,4,rep,name=sessions,proto3" json:"sessions,omitempty"`
}

func (m *ClientSnapshot) Reset()         { *m = ClientSnapshot{} }
func (m *ClientSnapshot) String() string { return proto.CompactTextString(m) }
func (*ClientSnapshot) ProtoMessage()    {}
func (*ClientSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{1}
}
func (m *ClientSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientSnapshot.Merge(m, src)
}
func (m *ClientSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *ClientSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ClientSnapshot proto.InternalMessageInfo

func (m *ClientSnapshot) GetClientID() ClientID {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *ClientSnapshot) GetSessionTimeout() time.Duration {
	if m != nil {
		return m.SessionTimeout
	}
	return 0
}

func (m *ClientSnapshot) GetLastUpdated() time.Time {
	if m != nil {
		return m.LastUpdated
	}
	return time.Time{}
}

func (m *ClientSnapshot) GetSessions() []*SessionSnapshot {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type SessionSnapshot struct {
	ServiceID        ServiceID                 `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3,casttype=ServiceID" json:"service_id"`
	SessionID        SessionID                 `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	LastRequestID    RequestID                 `protobuf:"varint,3,opt,name=last_request_id,json=lastRequestId,proto3,casttype=RequestID" json:"last_request_id,omitempty"`
	PendingRequests  []*SessionCommandRequest  `protobuf:"bytes,4,rep,name=pending_requests,json=pendingRequests,proto3" json:"pending_requests,omitempty"`
	PendingResponses []*SessionCommandResponse `protobuf:"bytes,5,rep,name=pending_responses,json=pendingResponses,proto3" json:"pending_responses,omitempty"`
	ResponseStreams  []*SessionStreamSnapshot  `protobuf:"bytes,6,rep,name=response_streams,json=responseStreams,proto3" json:"response_streams,omitempty"`
}

func (m *SessionSnapshot) Reset()         { *m = SessionSnapshot{} }
func (m *SessionSnapshot) String() string { return proto.CompactTextString(m) }
func (*SessionSnapshot) ProtoMessage()    {}
func (*SessionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{2}
}
func (m *SessionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionSnapshot.Merge(m, src)
}
func (m *SessionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *SessionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_SessionSnapshot proto.InternalMessageInfo

func (m *SessionSnapshot) GetServiceID() ServiceID {
	if m != nil {
		return m.ServiceID
	}
	return ServiceID{}
}

func (m *SessionSnapshot) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionSnapshot) GetLastRequestID() RequestID {
	if m != nil {
		return m.LastRequestID
	}
	return 0
}

func (m *SessionSnapshot) GetPendingRequests() []*SessionCommandRequest {
	if m != nil {
		return m.PendingRequests
	}
	return nil
}

func (m *SessionSnapshot) GetPendingResponses() []*SessionCommandResponse {
	if m != nil {
		return m.PendingResponses
	}
	return nil
}

func (m *SessionSnapshot) GetResponseStreams() []*SessionStreamSnapshot {
	if m != nil {
		return m.ResponseStreams
	}
	return nil
}

type SessionStreamSnapshot struct {
	RequestID        RequestID                 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	OperationID      OperationID               `protobuf:"varint,2,opt,name=operation_id,json=operationId,proto3,casttype=OperationID" json:"operation_id,omitempty"`
	LastResponseID   ResponseID                `protobuf:"varint,3,opt,name=last_response_id,json=lastResponseId,proto3,casttype=ResponseID" json:"last_response_id,omitempty"`
	PendingResponses []*SessionCommandResponse `protobuf:"bytes,4,rep,name=pending_responses,json=pendingResponses,proto3" json:"pending_responses,omitempty"`
}

func (m *SessionStreamSnapshot) Reset()         { *m = SessionStreamSnapshot{} }
func (m *SessionStreamSnapshot) String() string { return proto.CompactTextString(m) }
func (*SessionStreamSnapshot) ProtoMessage()    {}
func (*SessionStreamSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{3}
}
func (m *SessionStreamSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionStreamSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionStreamSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionStreamSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionStreamSnapshot.Merge(m, src)
}
func (m *SessionStreamSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *SessionStreamSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionStreamSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_SessionStreamSnapshot proto.InternalMessageInfo

func (m *SessionStreamSnapshot) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *SessionStreamSnapshot) GetOperationID() OperationID {
	if m != nil {
		return m.OperationID
	}
	return 0
}

func (m *SessionStreamSnapshot) GetLastResponseID() ResponseID {
	if m != nil {
		return m.LastResponseID
	}
	return 0
}

func (m *SessionStreamSnapshot) GetPendingResponses() []*SessionCommandResponse {
	if m != nil {
		return m.PendingResponses
	}
	return nil
}

type ServiceSnapshot struct {
	ServiceID ServiceID `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3,casttype=ServiceID" json:"service_id"`
	Index     Index     `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	Data      []byte    `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ServiceSnapshot) Reset()         { *m = ServiceSnapshot{} }
func (m *ServiceSnapshot) String() string { return proto.CompactTextString(m) }
func (*ServiceSnapshot) ProtoMessage()    {}
func (*ServiceSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{4}
}
func (m *ServiceSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceSnapshot.Merge(m, src)
}
func (m *ServiceSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *ServiceSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceSnapshot proto.InternalMessageInfo

func (m *ServiceSnapshot) GetServiceID() ServiceID {
	if m != nil {
		return m.ServiceID
	}
	return ServiceID{}
}

func (m *ServiceSnapshot) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ServiceSnapshot) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ServiceId struct {
	Type    string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Cluster string `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	Name    string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ServiceId) Reset()         { *m = ServiceId{} }
func (m *ServiceId) String() string { return proto.CompactTextString(m) }
func (*ServiceId) ProtoMessage()    {}
func (*ServiceId) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{5}
}
func (m *ServiceId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceId.Merge(m, src)
}
func (m *ServiceId) XXX_Size() int {
	return m.Size()
}
func (m *ServiceId) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceId.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceId proto.InternalMessageInfo

func (m *ServiceId) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ServiceId) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ServiceId) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PartitionConfigRequest struct {
	PartitionID uint32 `protobuf:"varint,1,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
}

func (m *PartitionConfigRequest) Reset()         { *m = PartitionConfigRequest{} }
func (m *PartitionConfigRequest) String() string { return proto.CompactTextString(m) }
func (*PartitionConfigRequest) ProtoMessage()    {}
func (*PartitionConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{6}
}
func (m *PartitionConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionConfigRequest.Merge(m, src)
}
func (m *PartitionConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartitionConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionConfigRequest proto.InternalMessageInfo

func (m *PartitionConfigRequest) GetPartitionID() uint32 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

type PartitionConfigResponse struct {
	Leader    string   `protobuf:"bytes,1,opt,name=leader,proto3" json:"leader,omitempty"`
	Followers []string `protobuf:"bytes,2,rep,name=followers,proto3" json:"followers,omitempty"`
}

func (m *PartitionConfigResponse) Reset()         { *m = PartitionConfigResponse{} }
func (m *PartitionConfigResponse) String() string { return proto.CompactTextString(m) }
func (*PartitionConfigResponse) ProtoMessage()    {}
func (*PartitionConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{7}
}
func (m *PartitionConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionConfigResponse.Merge(m, src)
}
func (m *PartitionConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *PartitionConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionConfigResponse proto.InternalMessageInfo

func (m *PartitionConfigResponse) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *PartitionConfigResponse) GetFollowers() []string {
	if m != nil {
		return m.Followers
	}
	return nil
}

type PartitionCommandRequest struct {
	PartitionID uint32                     `protobuf:"varint,1,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	Request     StateMachineCommandRequest `protobuf:"bytes,2,opt,name=request,proto3" json:"request"`
}

func (m *PartitionCommandRequest) Reset()         { *m = PartitionCommandRequest{} }
func (m *PartitionCommandRequest) String() string { return proto.CompactTextString(m) }
func (*PartitionCommandRequest) ProtoMessage()    {}
func (*PartitionCommandRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{8}
}
func (m *PartitionCommandRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionCommandRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionCommandRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionCommandRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionCommandRequest.Merge(m, src)
}
func (m *PartitionCommandRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartitionCommandRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionCommandRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionCommandRequest proto.InternalMessageInfo

func (m *PartitionCommandRequest) GetPartitionID() uint32 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

func (m *PartitionCommandRequest) GetRequest() StateMachineCommandRequest {
	if m != nil {
		return m.Request
	}
	return StateMachineCommandRequest{}
}

type PartitionCommandResponse struct {
	Response StateMachineCommandResponse `protobuf:"bytes,1,opt,name=response,proto3" json:"response"`
}

func (m *PartitionCommandResponse) Reset()         { *m = PartitionCommandResponse{} }
func (m *PartitionCommandResponse) String() string { return proto.CompactTextString(m) }
func (*PartitionCommandResponse) ProtoMessage()    {}
func (*PartitionCommandResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{9}
}
func (m *PartitionCommandResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionCommandResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionCommandResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionCommandResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionCommandResponse.Merge(m, src)
}
func (m *PartitionCommandResponse) XXX_Size() int {
	return m.Size()
}
func (m *PartitionCommandResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionCommandResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionCommandResponse proto.InternalMessageInfo

func (m *PartitionCommandResponse) GetResponse() StateMachineCommandResponse {
	if m != nil {
		return m.Response
	}
	return StateMachineCommandResponse{}
}

type StateMachineCommandRequest struct {
	Timestamp *time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*StateMachineCommandRequest_ClientConnect
	//	*StateMachineCommandRequest_ClientKeepAlive
	//	*StateMachineCommandRequest_ClientClose
	//	*StateMachineCommandRequest_ClientCommand
	Request isStateMachineCommandRequest_Request `protobuf_oneof:"request"`
}

func (m *StateMachineCommandRequest) Reset()         { *m = StateMachineCommandRequest{} }
func (m *StateMachineCommandRequest) String() string { return proto.CompactTextString(m) }
func (*StateMachineCommandRequest) ProtoMessage()    {}
func (*StateMachineCommandRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{10}
}
func (m *StateMachineCommandRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineCommandRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineCommandRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineCommandRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineCommandRequest.Merge(m, src)
}
func (m *StateMachineCommandRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineCommandRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineCommandRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineCommandRequest proto.InternalMessageInfo

type isStateMachineCommandRequest_Request interface {
	isStateMachineCommandRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StateMachineCommandRequest_ClientConnect struct {
	ClientConnect *ClientConnectRequest `protobuf:"bytes,2,opt,name=client_connect,json=clientConnect,proto3,oneof" json:"client_connect,omitempty"`
}
type StateMachineCommandRequest_ClientKeepAlive struct {
	ClientKeepAlive *ClientKeepAliveRequest `protobuf:"bytes,3,opt,name=client_keep_alive,json=clientKeepAlive,proto3,oneof" json:"client_keep_alive,omitempty"`
}
type StateMachineCommandRequest_ClientClose struct {
	ClientClose *ClientCloseRequest `protobuf:"bytes,4,opt,name=client_close,json=clientClose,proto3,oneof" json:"client_close,omitempty"`
}
type StateMachineCommandRequest_ClientCommand struct {
	ClientCommand *ClientCommandRequest `protobuf:"bytes,5,opt,name=client_command,json=clientCommand,proto3,oneof" json:"client_command,omitempty"`
}

func (*StateMachineCommandRequest_ClientConnect) isStateMachineCommandRequest_Request()   {}
func (*StateMachineCommandRequest_ClientKeepAlive) isStateMachineCommandRequest_Request() {}
func (*StateMachineCommandRequest_ClientClose) isStateMachineCommandRequest_Request()     {}
func (*StateMachineCommandRequest_ClientCommand) isStateMachineCommandRequest_Request()   {}

func (m *StateMachineCommandRequest) GetRequest() isStateMachineCommandRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *StateMachineCommandRequest) GetTimestamp() *time.Time {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *StateMachineCommandRequest) GetClientConnect() *ClientConnectRequest {
	if x, ok := m.GetRequest().(*StateMachineCommandRequest_ClientConnect); ok {
		return x.ClientConnect
	}
	return nil
}

func (m *StateMachineCommandRequest) GetClientKeepAlive() *ClientKeepAliveRequest {
	if x, ok := m.GetRequest().(*StateMachineCommandRequest_ClientKeepAlive); ok {
		return x.ClientKeepAlive
	}
	return nil
}

func (m *StateMachineCommandRequest) GetClientClose() *ClientCloseRequest {
	if x, ok := m.GetRequest().(*StateMachineCommandRequest_ClientClose); ok {
		return x.ClientClose
	}
	return nil
}

func (m *StateMachineCommandRequest) GetClientCommand() *ClientCommandRequest {
	if x, ok := m.GetRequest().(*StateMachineCommandRequest_ClientCommand); ok {
		return x.ClientCommand
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StateMachineCommandRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StateMachineCommandRequest_ClientConnect)(nil),
		(*StateMachineCommandRequest_ClientKeepAlive)(nil),
		(*StateMachineCommandRequest_ClientClose)(nil),
		(*StateMachineCommandRequest_ClientCommand)(nil),
	}
}

type StateMachineCommandResponse struct {
	Index Index `protobuf:"varint,1,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	// Types that are valid to be assigned to Response:
	//	*StateMachineCommandResponse_ClientConnect
	//	*StateMachineCommandResponse_ClientKeepAlive
	//	*StateMachineCommandResponse_ClientClose
	//	*StateMachineCommandResponse_ClientCommand
	Response isStateMachineCommandResponse_Response `protobuf_oneof:"response"`
}

func (m *StateMachineCommandResponse) Reset()         { *m = StateMachineCommandResponse{} }
func (m *StateMachineCommandResponse) String() string { return proto.CompactTextString(m) }
func (*StateMachineCommandResponse) ProtoMessage()    {}
func (*StateMachineCommandResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{11}
}
func (m *StateMachineCommandResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineCommandResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineCommandResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineCommandResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineCommandResponse.Merge(m, src)
}
func (m *StateMachineCommandResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineCommandResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineCommandResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineCommandResponse proto.InternalMessageInfo

type isStateMachineCommandResponse_Response interface {
	isStateMachineCommandResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StateMachineCommandResponse_ClientConnect struct {
	ClientConnect *ClientConnectResponse `protobuf:"bytes,2,opt,name=client_connect,json=clientConnect,proto3,oneof" json:"client_connect,omitempty"`
}
type StateMachineCommandResponse_ClientKeepAlive struct {
	ClientKeepAlive *ClientKeepAliveResponse `protobuf:"bytes,3,opt,name=client_keep_alive,json=clientKeepAlive,proto3,oneof" json:"client_keep_alive,omitempty"`
}
type StateMachineCommandResponse_ClientClose struct {
	ClientClose *ClientCloseResponse `protobuf:"bytes,4,opt,name=client_close,json=clientClose,proto3,oneof" json:"client_close,omitempty"`
}
type StateMachineCommandResponse_ClientCommand struct {
	ClientCommand *ClientCommandResponse `protobuf:"bytes,5,opt,name=client_command,json=clientCommand,proto3,oneof" json:"client_command,omitempty"`
}

func (*StateMachineCommandResponse_ClientConnect) isStateMachineCommandResponse_Response()   {}
func (*StateMachineCommandResponse_ClientKeepAlive) isStateMachineCommandResponse_Response() {}
func (*StateMachineCommandResponse_ClientClose) isStateMachineCommandResponse_Response()     {}
func (*StateMachineCommandResponse_ClientCommand) isStateMachineCommandResponse_Response()   {}

func (m *StateMachineCommandResponse) GetResponse() isStateMachineCommandResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *StateMachineCommandResponse) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StateMachineCommandResponse) GetClientConnect() *ClientConnectResponse {
	if x, ok := m.GetResponse().(*StateMachineCommandResponse_ClientConnect); ok {
		return x.ClientConnect
	}
	return nil
}

func (m *StateMachineCommandResponse) GetClientKeepAlive() *ClientKeepAliveResponse {
	if x, ok := m.GetResponse().(*StateMachineCommandResponse_ClientKeepAlive); ok {
		return x.ClientKeepAlive
	}
	return nil
}

func (m *StateMachineCommandResponse) GetClientClose() *ClientCloseResponse {
	if x, ok := m.GetResponse().(*StateMachineCommandResponse_ClientClose); ok {
		return x.ClientClose
	}
	return nil
}

func (m *StateMachineCommandResponse) GetClientCommand() *ClientCommandResponse {
	if x, ok := m.GetResponse().(*StateMachineCommandResponse_ClientCommand); ok {
		return x.ClientCommand
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StateMachineCommandResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StateMachineCommandResponse_ClientConnect)(nil),
		(*StateMachineCommandResponse_ClientKeepAlive)(nil),
		(*StateMachineCommandResponse_ClientClose)(nil),
		(*StateMachineCommandResponse_ClientCommand)(nil),
	}
}

type ClientConnectRequest struct {
	SessionTimeout time.Duration `protobuf:"bytes,2,opt,name=session_timeout,json=sessionTimeout,proto3,stdduration" json:"session_timeout"`
}

func (m *ClientConnectRequest) Reset()         { *m = ClientConnectRequest{} }
func (m *ClientConnectRequest) String() string { return proto.CompactTextString(m) }
func (*ClientConnectRequest) ProtoMessage()    {}
func (*ClientConnectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{12}
}
func (m *ClientConnectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientConnectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientConnectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientConnectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientConnectRequest.Merge(m, src)
}
func (m *ClientConnectRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientConnectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientConnectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientConnectRequest proto.InternalMessageInfo

func (m *ClientConnectRequest) GetSessionTimeout() time.Duration {
	if m != nil {
		return m.SessionTimeout
	}
	return 0
}

type ClientConnectResponse struct {
	ClientID ClientID `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3,casttype=ClientID" json:"client_id,omitempty"`
}

func (m *ClientConnectResponse) Reset()         { *m = ClientConnectResponse{} }
func (m *ClientConnectResponse) String() string { return proto.CompactTextString(m) }
func (*ClientConnectResponse) ProtoMessage()    {}
func (*ClientConnectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{13}
}
func (m *ClientConnectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientConnectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientConnectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientConnectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientConnectResponse.Merge(m, src)
}
func (m *ClientConnectResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientConnectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientConnectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientConnectResponse proto.InternalMessageInfo

func (m *ClientConnectResponse) GetClientID() ClientID {
	if m != nil {
		return m.ClientID
	}
	return 0
}

type ClientKeepAliveRequest struct {
	State ClientState `protobuf:"bytes,1,opt,name=state,proto3" json:"state"`
}

func (m *ClientKeepAliveRequest) Reset()         { *m = ClientKeepAliveRequest{} }
func (m *ClientKeepAliveRequest) String() string { return proto.CompactTextString(m) }
func (*ClientKeepAliveRequest) ProtoMessage()    {}
func (*ClientKeepAliveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{14}
}
func (m *ClientKeepAliveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientKeepAliveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientKeepAliveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientKeepAliveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientKeepAliveRequest.Merge(m, src)
}
func (m *ClientKeepAliveRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientKeepAliveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientKeepAliveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientKeepAliveRequest proto.InternalMessageInfo

func (m *ClientKeepAliveRequest) GetState() ClientState {
	if m != nil {
		return m.State
	}
	return ClientState{}
}

type ClientState struct {
	ClientID ClientID       `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3,casttype=ClientID" json:"client_id,omitempty"`
	Sessions []SessionState `protobuf:"bytes,2,rep,name=sessions,proto3" json:"sessions"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{15}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

func (m *ClientState) GetClientID() ClientID {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *ClientState) GetSessions() []SessionState {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type SessionState struct {
	SessionID       SessionID     `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	PendingRequests []byte        `protobuf:"bytes,2,opt,name=pending_requests,json=pendingRequests,proto3" json:"pending_requests,omitempty"`
	ResponseStreams []StreamState `protobuf:"bytes,3,rep,name=response_streams,json=responseStreams,proto3" json:"response_streams"`
}

func (m *SessionState) Reset()         { *m = SessionState{} }
func (m *SessionState) String() string { return proto.CompactTextString(m) }
func (*SessionState) ProtoMessage()    {}
func (*SessionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{16}
}
func (m *SessionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionState.Merge(m, src)
}
func (m *SessionState) XXX_Size() int {
	return m.Size()
}
func (m *SessionState) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionState.DiscardUnknown(m)
}

var xxx_messageInfo_SessionState proto.InternalMessageInfo

func (m *SessionState) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionState) GetPendingRequests() []byte {
	if m != nil {
		return m.PendingRequests
	}
	return nil
}

func (m *SessionState) GetResponseStreams() []StreamState {
	if m != nil {
		return m.ResponseStreams
	}
	return nil
}

type StreamState struct {
	RequestID          RequestID  `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	CompleteResponseID ResponseID `protobuf:"varint,2,opt,name=complete_response_id,json=completeResponseId,proto3,casttype=ResponseID" json:"complete_response_id,omitempty"`
}

func (m *StreamState) Reset()         { *m = StreamState{} }
func (m *StreamState) String() string { return proto.CompactTextString(m) }
func (*StreamState) ProtoMessage()    {}
func (*StreamState) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{17}
}
func (m *StreamState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamState.Merge(m, src)
}
func (m *StreamState) XXX_Size() int {
	return m.Size()
}
func (m *StreamState) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamState.DiscardUnknown(m)
}

var xxx_messageInfo_StreamState proto.InternalMessageInfo

func (m *StreamState) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *StreamState) GetCompleteResponseID() ResponseID {
	if m != nil {
		return m.CompleteResponseID
	}
	return 0
}

type ClientKeepAliveResponse struct {
}

func (m *ClientKeepAliveResponse) Reset()         { *m = ClientKeepAliveResponse{} }
func (m *ClientKeepAliveResponse) String() string { return proto.CompactTextString(m) }
func (*ClientKeepAliveResponse) ProtoMessage()    {}
func (*ClientKeepAliveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{18}
}
func (m *ClientKeepAliveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientKeepAliveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientKeepAliveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientKeepAliveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientKeepAliveResponse.Merge(m, src)
}
func (m *ClientKeepAliveResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientKeepAliveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientKeepAliveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientKeepAliveResponse proto.InternalMessageInfo

type ClientCloseRequest struct {
	ClientID ClientID `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3,casttype=ClientID" json:"client_id,omitempty"`
}

func (m *ClientCloseRequest) Reset()         { *m = ClientCloseRequest{} }
func (m *ClientCloseRequest) String() string { return proto.CompactTextString(m) }
func (*ClientCloseRequest) ProtoMessage()    {}
func (*ClientCloseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{19}
}
func (m *ClientCloseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCloseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCloseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCloseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCloseRequest.Merge(m, src)
}
func (m *ClientCloseRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientCloseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCloseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCloseRequest proto.InternalMessageInfo

func (m *ClientCloseRequest) GetClientID() ClientID {
	if m != nil {
		return m.ClientID
	}
	return 0
}

type ClientCloseResponse struct {
}

func (m *ClientCloseResponse) Reset()         { *m = ClientCloseResponse{} }
func (m *ClientCloseResponse) String() string { return proto.CompactTextString(m) }
func (*ClientCloseResponse) ProtoMessage()    {}
func (*ClientCloseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{20}
}
func (m *ClientCloseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCloseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCloseResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCloseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCloseResponse.Merge(m, src)
}
func (m *ClientCloseResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientCloseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCloseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCloseResponse proto.InternalMessageInfo

type ClientCommandRequest struct {
	ClientID ClientID `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3,casttype=ClientID" json:"client_id,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*ClientCommandRequest_SessionOpen
	//	*ClientCommandRequest_SessionClose
	//	*ClientCommandRequest_SessionCommand
	Request isClientCommandRequest_Request `protobuf_oneof:"request"`
}

func (m *ClientCommandRequest) Reset()         { *m = ClientCommandRequest{} }
func (m *ClientCommandRequest) String() string { return proto.CompactTextString(m) }
func (*ClientCommandRequest) ProtoMessage()    {}
func (*ClientCommandRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{21}
}
func (m *ClientCommandRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCommandRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCommandRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCommandRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCommandRequest.Merge(m, src)
}
func (m *ClientCommandRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientCommandRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCommandRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCommandRequest proto.InternalMessageInfo

type isClientCommandRequest_Request interface {
	isClientCommandRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCommandRequest_SessionOpen struct {
	SessionOpen *SessionOpenRequest `protobuf:"bytes,2,opt,name=session_open,json=sessionOpen,proto3,oneof" json:"session_open,omitempty"`
}
type ClientCommandRequest_SessionClose struct {
	SessionClose *SessionCloseRequest `protobuf:"bytes,3,opt,name=session_close,json=sessionClose,proto3,oneof" json:"session_close,omitempty"`
}
type ClientCommandRequest_SessionCommand struct {
	SessionCommand *SessionCommandRequest `protobuf:"bytes,4,opt,name=session_command,json=sessionCommand,proto3,oneof" json:"session_command,omitempty"`
}

func (*ClientCommandRequest_SessionOpen) isClientCommandRequest_Request()    {}
func (*ClientCommandRequest_SessionClose) isClientCommandRequest_Request()   {}
func (*ClientCommandRequest_SessionCommand) isClientCommandRequest_Request() {}

func (m *ClientCommandRequest) GetRequest() isClientCommandRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ClientCommandRequest) GetClientID() ClientID {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *ClientCommandRequest) GetSessionOpen() *SessionOpenRequest {
	if x, ok := m.GetRequest().(*ClientCommandRequest_SessionOpen); ok {
		return x.SessionOpen
	}
	return nil
}

func (m *ClientCommandRequest) GetSessionClose() *SessionCloseRequest {
	if x, ok := m.GetRequest().(*ClientCommandRequest_SessionClose); ok {
		return x.SessionClose
	}
	return nil
}

func (m *ClientCommandRequest) GetSessionCommand() *SessionCommandRequest {
	if x, ok := m.GetRequest().(*ClientCommandRequest_SessionCommand); ok {
		return x.SessionCommand
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientCommandRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientCommandRequest_SessionOpen)(nil),
		(*ClientCommandRequest_SessionClose)(nil),
		(*ClientCommandRequest_SessionCommand)(nil),
	}
}

type ClientCommandResponse struct {
	// Types that are valid to be assigned to Response:
	//	*ClientCommandResponse_SessionOpen
	//	*ClientCommandResponse_SessionClose
	//	*ClientCommandResponse_SessionCommand
	Response isClientCommandResponse_Response `protobuf_oneof:"response"`
}

func (m *ClientCommandResponse) Reset()         { *m = ClientCommandResponse{} }
func (m *ClientCommandResponse) String() string { return proto.CompactTextString(m) }
func (*ClientCommandResponse) ProtoMessage()    {}
func (*ClientCommandResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{22}
}
func (m *ClientCommandResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientCommandResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientCommandResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientCommandResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientCommandResponse.Merge(m, src)
}
func (m *ClientCommandResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientCommandResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientCommandResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientCommandResponse proto.InternalMessageInfo

type isClientCommandResponse_Response interface {
	isClientCommandResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientCommandResponse_SessionOpen struct {
	SessionOpen *SessionOpenResponse `protobuf:"bytes,1,opt,name=session_open,json=sessionOpen,proto3,oneof" json:"session_open,omitempty"`
}
type ClientCommandResponse_SessionClose struct {
	SessionClose *SessionCloseResponse `protobuf:"bytes,2,opt,name=session_close,json=sessionClose,proto3,oneof" json:"session_close,omitempty"`
}
type ClientCommandResponse_SessionCommand struct {
	SessionCommand *SessionCommandResponse `protobuf:"bytes,3,opt,name=session_command,json=sessionCommand,proto3,oneof" json:"session_command,omitempty"`
}

func (*ClientCommandResponse_SessionOpen) isClientCommandResponse_Response()    {}
func (*ClientCommandResponse_SessionClose) isClientCommandResponse_Response()   {}
func (*ClientCommandResponse_SessionCommand) isClientCommandResponse_Response() {}

func (m *ClientCommandResponse) GetResponse() isClientCommandResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *ClientCommandResponse) GetSessionOpen() *SessionOpenResponse {
	if x, ok := m.GetResponse().(*ClientCommandResponse_SessionOpen); ok {
		return x.SessionOpen
	}
	return nil
}

func (m *ClientCommandResponse) GetSessionClose() *SessionCloseResponse {
	if x, ok := m.GetResponse().(*ClientCommandResponse_SessionClose); ok {
		return x.SessionClose
	}
	return nil
}

func (m *ClientCommandResponse) GetSessionCommand() *SessionCommandResponse {
	if x, ok := m.GetResponse().(*ClientCommandResponse_SessionCommand); ok {
		return x.SessionCommand
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientCommandResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientCommandResponse_SessionOpen)(nil),
		(*ClientCommandResponse_SessionClose)(nil),
		(*ClientCommandResponse_SessionCommand)(nil),
	}
}

type SessionOpenRequest struct {
	ServiceID ServiceID `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3,casttype=ServiceID" json:"service_id"`
}

func (m *SessionOpenRequest) Reset()         { *m = SessionOpenRequest{} }
func (m *SessionOpenRequest) String() string { return proto.CompactTextString(m) }
func (*SessionOpenRequest) ProtoMessage()    {}
func (*SessionOpenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{23}
}
func (m *SessionOpenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionOpenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionOpenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionOpenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionOpenRequest.Merge(m, src)
}
func (m *SessionOpenRequest) XXX_Size() int {
	return m.Size()
}
func (m *SessionOpenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionOpenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SessionOpenRequest proto.InternalMessageInfo

func (m *SessionOpenRequest) GetServiceID() ServiceID {
	if m != nil {
		return m.ServiceID
	}
	return ServiceID{}
}

type SessionOpenResponse struct {
	SessionID SessionID `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
}

func (m *SessionOpenResponse) Reset()         { *m = SessionOpenResponse{} }
func (m *SessionOpenResponse) String() string { return proto.CompactTextString(m) }
func (*SessionOpenResponse) ProtoMessage()    {}
func (*SessionOpenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{24}
}
func (m *SessionOpenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionOpenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionOpenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionOpenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionOpenResponse.Merge(m, src)
}
func (m *SessionOpenResponse) XXX_Size() int {
	return m.Size()
}
func (m *SessionOpenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionOpenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SessionOpenResponse proto.InternalMessageInfo

func (m *SessionOpenResponse) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

type SessionCloseRequest struct {
	SessionID SessionID `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
}

func (m *SessionCloseRequest) Reset()         { *m = SessionCloseRequest{} }
func (m *SessionCloseRequest) String() string { return proto.CompactTextString(m) }
func (*SessionCloseRequest) ProtoMessage()    {}
func (*SessionCloseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{25}
}
func (m *SessionCloseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionCloseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionCloseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionCloseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionCloseRequest.Merge(m, src)
}
func (m *SessionCloseRequest) XXX_Size() int {
	return m.Size()
}
func (m *SessionCloseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionCloseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SessionCloseRequest proto.InternalMessageInfo

func (m *SessionCloseRequest) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

type SessionCloseResponse struct {
}

func (m *SessionCloseResponse) Reset()         { *m = SessionCloseResponse{} }
func (m *SessionCloseResponse) String() string { return proto.CompactTextString(m) }
func (*SessionCloseResponse) ProtoMessage()    {}
func (*SessionCloseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{26}
}
func (m *SessionCloseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionCloseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionCloseResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionCloseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionCloseResponse.Merge(m, src)
}
func (m *SessionCloseResponse) XXX_Size() int {
	return m.Size()
}
func (m *SessionCloseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionCloseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SessionCloseResponse proto.InternalMessageInfo

type SessionCommandRequest struct {
	SessionID SessionID `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	RequestID RequestID `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*SessionCommandRequest_Operation
	Request isSessionCommandRequest_Request `protobuf_oneof:"request"`
}

func (m *SessionCommandRequest) Reset()         { *m = SessionCommandRequest{} }
func (m *SessionCommandRequest) String() string { return proto.CompactTextString(m) }
func (*SessionCommandRequest) ProtoMessage()    {}
func (*SessionCommandRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{27}
}
func (m *SessionCommandRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionCommandRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionCommandRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionCommandRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionCommandRequest.Merge(m, src)
}
func (m *SessionCommandRequest) XXX_Size() int {
	return m.Size()
}
func (m *SessionCommandRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionCommandRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SessionCommandRequest proto.InternalMessageInfo

type isSessionCommandRequest_Request interface {
	isSessionCommandRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionCommandRequest_Operation struct {
	Operation *OperationRequest `protobuf:"bytes,3,opt,name=operation,proto3,oneof" json:"operation,omitempty"`
}

func (*SessionCommandRequest_Operation) isSessionCommandRequest_Request() {}

func (m *SessionCommandRequest) GetRequest() isSessionCommandRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SessionCommandRequest) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionCommandRequest) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *SessionCommandRequest) GetOperation() *OperationRequest {
	if x, ok := m.GetRequest().(*SessionCommandRequest_Operation); ok {
		return x.Operation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionCommandRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionCommandRequest_Operation)(nil),
	}
}

type SessionCommandResponse struct {
	ResponseID ResponseID `protobuf:"varint,1,opt,name=response_id,json=responseId,proto3,casttype=ResponseID" json:"response_id,omitempty"`
	// Types that are valid to be assigned to Response:
	//	*SessionCommandResponse_Operation
	Response isSessionCommandResponse_Response `protobuf_oneof:"response"`
}

func (m *SessionCommandResponse) Reset()         { *m = SessionCommandResponse{} }
func (m *SessionCommandResponse) String() string { return proto.CompactTextString(m) }
func (*SessionCommandResponse) ProtoMessage()    {}
func (*SessionCommandResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{28}
}
func (m *SessionCommandResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionCommandResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionCommandResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionCommandResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionCommandResponse.Merge(m, src)
}
func (m *SessionCommandResponse) XXX_Size() int {
	return m.Size()
}
func (m *SessionCommandResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionCommandResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SessionCommandResponse proto.InternalMessageInfo

type isSessionCommandResponse_Response interface {
	isSessionCommandResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionCommandResponse_Operation struct {
	Operation *OperationResponse `protobuf:"bytes,2,opt,name=operation,proto3,oneof" json:"operation,omitempty"`
}

func (*SessionCommandResponse_Operation) isSessionCommandResponse_Response() {}

func (m *SessionCommandResponse) GetResponse() isSessionCommandResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SessionCommandResponse) GetResponseID() ResponseID {
	if m != nil {
		return m.ResponseID
	}
	return 0
}

func (m *SessionCommandResponse) GetOperation() *OperationResponse {
	if x, ok := m.GetResponse().(*SessionCommandResponse_Operation); ok {
		return x.Operation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionCommandResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionCommandResponse_Operation)(nil),
	}
}

type PartitionQueryRequest struct {
	PartitionID uint32                   `protobuf:"varint,1,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	Request     StateMachineQueryRequest `protobuf:"bytes,2,opt,name=request,proto3" json:"request"`
}

func (m *PartitionQueryRequest) Reset()         { *m = PartitionQueryRequest{} }
func (m *PartitionQueryRequest) String() string { return proto.CompactTextString(m) }
func (*PartitionQueryRequest) ProtoMessage()    {}
func (*PartitionQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{29}
}
func (m *PartitionQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionQueryRequest.Merge(m, src)
}
func (m *PartitionQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartitionQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionQueryRequest proto.InternalMessageInfo

func (m *PartitionQueryRequest) GetPartitionID() uint32 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

func (m *PartitionQueryRequest) GetRequest() StateMachineQueryRequest {
	if m != nil {
		return m.Request
	}
	return StateMachineQueryRequest{}
}

type PartitionQueryResponse struct {
	Response StateMachineQueryResponse `protobuf:"bytes,1,opt,name=response,proto3" json:"response"`
}

func (m *PartitionQueryResponse) Reset()         { *m = PartitionQueryResponse{} }
func (m *PartitionQueryResponse) String() string { return proto.CompactTextString(m) }
func (*PartitionQueryResponse) ProtoMessage()    {}
func (*PartitionQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{30}
}
func (m *PartitionQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionQueryResponse.Merge(m, src)
}
func (m *PartitionQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *PartitionQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionQueryResponse proto.InternalMessageInfo

func (m *PartitionQueryResponse) GetResponse() StateMachineQueryResponse {
	if m != nil {
		return m.Response
	}
	return StateMachineQueryResponse{}
}

type StateMachineQueryRequest struct {
	SyncIndex Index `protobuf:"varint,1,opt,name=sync_index,json=syncIndex,proto3,casttype=Index" json:"sync_index,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*StateMachineQueryRequest_ClientQuery
	Request isStateMachineQueryRequest_Request `protobuf_oneof:"request"`
}

func (m *StateMachineQueryRequest) Reset()         { *m = StateMachineQueryRequest{} }
func (m *StateMachineQueryRequest) String() string { return proto.CompactTextString(m) }
func (*StateMachineQueryRequest) ProtoMessage()    {}
func (*StateMachineQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{31}
}
func (m *StateMachineQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineQueryRequest.Merge(m, src)
}
func (m *StateMachineQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineQueryRequest proto.InternalMessageInfo

type isStateMachineQueryRequest_Request interface {
	isStateMachineQueryRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StateMachineQueryRequest_ClientQuery struct {
	ClientQuery *ClientQueryRequest `protobuf:"bytes,2,opt,name=client_query,json=clientQuery,proto3,oneof" json:"client_query,omitempty"`
}

func (*StateMachineQueryRequest_ClientQuery) isStateMachineQueryRequest_Request() {}

func (m *StateMachineQueryRequest) GetRequest() isStateMachineQueryRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *StateMachineQueryRequest) GetSyncIndex() Index {
	if m != nil {
		return m.SyncIndex
	}
	return 0
}

func (m *StateMachineQueryRequest) GetClientQuery() *ClientQueryRequest {
	if x, ok := m.GetRequest().(*StateMachineQueryRequest_ClientQuery); ok {
		return x.ClientQuery
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StateMachineQueryRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StateMachineQueryRequest_ClientQuery)(nil),
	}
}

type StateMachineQueryResponse struct {
	Index Index `protobuf:"varint,1,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	// Types that are valid to be assigned to Response:
	//	*StateMachineQueryResponse_ClientQuery
	Response isStateMachineQueryResponse_Response `protobuf_oneof:"response"`
}

func (m *StateMachineQueryResponse) Reset()         { *m = StateMachineQueryResponse{} }
func (m *StateMachineQueryResponse) String() string { return proto.CompactTextString(m) }
func (*StateMachineQueryResponse) ProtoMessage()    {}
func (*StateMachineQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{32}
}
func (m *StateMachineQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineQueryResponse.Merge(m, src)
}
func (m *StateMachineQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineQueryResponse proto.InternalMessageInfo

type isStateMachineQueryResponse_Response interface {
	isStateMachineQueryResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StateMachineQueryResponse_ClientQuery struct {
	ClientQuery *ClientQueryResponse `protobuf:"bytes,2,opt,name=client_query,json=clientQuery,proto3,oneof" json:"client_query,omitempty"`
}

func (*StateMachineQueryResponse_ClientQuery) isStateMachineQueryResponse_Response() {}

func (m *StateMachineQueryResponse) GetResponse() isStateMachineQueryResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *StateMachineQueryResponse) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StateMachineQueryResponse) GetClientQuery() *ClientQueryResponse {
	if x, ok := m.GetResponse().(*StateMachineQueryResponse_ClientQuery); ok {
		return x.ClientQuery
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StateMachineQueryResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StateMachineQueryResponse_ClientQuery)(nil),
	}
}

type ClientQueryRequest struct {
	ClientID ClientID `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3,casttype=ClientID" json:"client_id,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*ClientQueryRequest_SessionQuery
	Request isClientQueryRequest_Request `protobuf_oneof:"request"`
}

func (m *ClientQueryRequest) Reset()         { *m = ClientQueryRequest{} }
func (m *ClientQueryRequest) String() string { return proto.CompactTextString(m) }
func (*ClientQueryRequest) ProtoMessage()    {}
func (*ClientQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{33}
}
func (m *ClientQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientQueryRequest.Merge(m, src)
}
func (m *ClientQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientQueryRequest proto.InternalMessageInfo

type isClientQueryRequest_Request interface {
	isClientQueryRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientQueryRequest_SessionQuery struct {
	SessionQuery *SessionQueryRequest `protobuf:"bytes,2,opt,name=session_query,json=sessionQuery,proto3,oneof" json:"session_query,omitempty"`
}

func (*ClientQueryRequest_SessionQuery) isClientQueryRequest_Request() {}

func (m *ClientQueryRequest) GetRequest() isClientQueryRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ClientQueryRequest) GetClientID() ClientID {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *ClientQueryRequest) GetSessionQuery() *SessionQueryRequest {
	if x, ok := m.GetRequest().(*ClientQueryRequest_SessionQuery); ok {
		return x.SessionQuery
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientQueryRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientQueryRequest_SessionQuery)(nil),
	}
}

type ClientQueryResponse struct {
	// Types that are valid to be assigned to Response:
	//	*ClientQueryResponse_SessionQuery
	Response isClientQueryResponse_Response `protobuf_oneof:"response"`
}

func (m *ClientQueryResponse) Reset()         { *m = ClientQueryResponse{} }
func (m *ClientQueryResponse) String() string { return proto.CompactTextString(m) }
func (*ClientQueryResponse) ProtoMessage()    {}
func (*ClientQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{34}
}
func (m *ClientQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientQueryResponse.Merge(m, src)
}
func (m *ClientQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientQueryResponse proto.InternalMessageInfo

type isClientQueryResponse_Response interface {
	isClientQueryResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientQueryResponse_SessionQuery struct {
	SessionQuery *SessionQueryResponse `protobuf:"bytes,1,opt,name=session_query,json=sessionQuery,proto3,oneof" json:"session_query,omitempty"`
}

func (*ClientQueryResponse_SessionQuery) isClientQueryResponse_Response() {}

func (m *ClientQueryResponse) GetResponse() isClientQueryResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *ClientQueryResponse) GetSessionQuery() *SessionQueryResponse {
	if x, ok := m.GetResponse().(*ClientQueryResponse_SessionQuery); ok {
		return x.SessionQuery
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientQueryResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientQueryResponse_SessionQuery)(nil),
	}
}

type SessionQueryRequest struct {
	SessionID     SessionID `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	LastRequestID RequestID `protobuf:"varint,2,opt,name=last_request_id,json=lastRequestId,proto3,casttype=RequestID" json:"last_request_id,omitempty"`
	// Types that are valid to be assigned to Request:
	//	*SessionQueryRequest_Operation
	Request isSessionQueryRequest_Request `protobuf_oneof:"request"`
}

func (m *SessionQueryRequest) Reset()         { *m = SessionQueryRequest{} }
func (m *SessionQueryRequest) String() string { return proto.CompactTextString(m) }
func (*SessionQueryRequest) ProtoMessage()    {}
func (*SessionQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{35}
}
func (m *SessionQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionQueryRequest.Merge(m, src)
}
func (m *SessionQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *SessionQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SessionQueryRequest proto.InternalMessageInfo

type isSessionQueryRequest_Request interface {
	isSessionQueryRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionQueryRequest_Operation struct {
	Operation *OperationRequest `protobuf:"bytes,3,opt,name=operation,proto3,oneof" json:"operation,omitempty"`
}

func (*SessionQueryRequest_Operation) isSessionQueryRequest_Request() {}

func (m *SessionQueryRequest) GetRequest() isSessionQueryRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SessionQueryRequest) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionQueryRequest) GetLastRequestID() RequestID {
	if m != nil {
		return m.LastRequestID
	}
	return 0
}

func (m *SessionQueryRequest) GetOperation() *OperationRequest {
	if x, ok := m.GetRequest().(*SessionQueryRequest_Operation); ok {
		return x.Operation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionQueryRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionQueryRequest_Operation)(nil),
	}
}

type SessionQueryResponse struct {
	ResponseID ResponseID `protobuf:"varint,1,opt,name=response_id,json=responseId,proto3,casttype=ResponseID" json:"response_id,omitempty"`
	// Types that are valid to be assigned to Response:
	//	*SessionQueryResponse_Operation
	Response isSessionQueryResponse_Response `protobuf_oneof:"response"`
}

func (m *SessionQueryResponse) Reset()         { *m = SessionQueryResponse{} }
func (m *SessionQueryResponse) String() string { return proto.CompactTextString(m) }
func (*SessionQueryResponse) ProtoMessage()    {}
func (*SessionQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{36}
}
func (m *SessionQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionQueryResponse.Merge(m, src)
}
func (m *SessionQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *SessionQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SessionQueryResponse proto.InternalMessageInfo

type isSessionQueryResponse_Response interface {
	isSessionQueryResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionQueryResponse_Operation struct {
	Operation *OperationResponse `protobuf:"bytes,2,opt,name=operation,proto3,oneof" json:"operation,omitempty"`
}

func (*SessionQueryResponse_Operation) isSessionQueryResponse_Response() {}

func (m *SessionQueryResponse) GetResponse() isSessionQueryResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SessionQueryResponse) GetResponseID() ResponseID {
	if m != nil {
		return m.ResponseID
	}
	return 0
}

func (m *SessionQueryResponse) GetOperation() *OperationResponse {
	if x, ok := m.GetResponse().(*SessionQueryResponse_Operation); ok {
		return x.Operation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionQueryResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionQueryResponse_Operation)(nil),
	}
}

type OperationRequest struct {
	OperationID OperationID `protobuf:"varint,1,opt,name=operation_id,json=operationId,proto3,casttype=OperationID" json:"operation_id,omitempty"`
	Value       []byte      `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *OperationRequest) Reset()         { *m = OperationRequest{} }
func (m *OperationRequest) String() string { return proto.CompactTextString(m) }
func (*OperationRequest) ProtoMessage()    {}
func (*OperationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{37}
}
func (m *OperationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperationRequest.Merge(m, src)
}
func (m *OperationRequest) XXX_Size() int {
	return m.Size()
}
func (m *OperationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OperationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OperationRequest proto.InternalMessageInfo

func (m *OperationRequest) GetOperationID() OperationID {
	if m != nil {
		return m.OperationID
	}
	return 0
}

func (m *OperationRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type OperationResponse struct {
	Status ResponseStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status"`
	Value  []byte         `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *OperationResponse) Reset()         { *m = OperationResponse{} }
func (m *OperationResponse) String() string { return proto.CompactTextString(m) }
func (*OperationResponse) ProtoMessage()    {}
func (*OperationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{38}
}
func (m *OperationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperationResponse.Merge(m, src)
}
func (m *OperationResponse) XXX_Size() int {
	return m.Size()
}
func (m *OperationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OperationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OperationResponse proto.InternalMessageInfo

func (m *OperationResponse) GetStatus() ResponseStatus {
	if m != nil {
		return m.Status
	}
	return ResponseStatus{}
}

func (m *OperationResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type ResponseStatus struct {
	Code    ResponseCode `protobuf:"varint,1,opt,name=code,proto3,enum=atomix.service.ResponseCode" json:"code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Leader  string       `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
}

func (m *ResponseStatus) Reset()         { *m = ResponseStatus{} }
func (m *ResponseStatus) String() string { return proto.CompactTextString(m) }
func (*ResponseStatus) ProtoMessage()    {}
func (*ResponseStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2862b69821520282, []int{39}
}
func (m *ResponseStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseStatus.Merge(m, src)
}
func (m *ResponseStatus) XXX_Size() int {
	return m.Size()
}
func (m *ResponseStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseStatus proto.InternalMessageInfo

func (m *ResponseStatus) GetCode() ResponseCode {
	if m != nil {
		return m.Code
	}
	return ResponseCode_OK
}

func (m *ResponseStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ResponseStatus) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func init() {
	proto.RegisterEnum("atomix.service.ResponseCode", ResponseCode_name, ResponseCode_value)
	proto.RegisterType((*StateMachineSnapshot)(nil), "atomix.service.StateMachineSnapshot")
	proto.RegisterType((*ClientSnapshot)(nil), "atomix.service.ClientSnapshot")
	proto.RegisterType((*SessionSnapshot)(nil), "atomix.service.SessionSnapshot")
	proto.RegisterType((*SessionStreamSnapshot)(nil), "atomix.service.SessionStreamSnapshot")
	proto.RegisterType((*ServiceSnapshot)(nil), "atomix.service.ServiceSnapshot")
	proto.RegisterType((*ServiceId)(nil), "atomix.service.ServiceId")
	proto.RegisterType((*PartitionConfigRequest)(nil), "atomix.service.PartitionConfigRequest")
	proto.RegisterType((*PartitionConfigResponse)(nil), "atomix.service.PartitionConfigResponse")
	proto.RegisterType((*PartitionCommandRequest)(nil), "atomix.service.PartitionCommandRequest")
	proto.RegisterType((*PartitionCommandResponse)(nil), "atomix.service.PartitionCommandResponse")
	proto.RegisterType((*StateMachineCommandRequest)(nil), "atomix.service.StateMachineCommandRequest")
	proto.RegisterType((*StateMachineCommandResponse)(nil), "atomix.service.StateMachineCommandResponse")
	proto.RegisterType((*ClientConnectRequest)(nil), "atomix.service.ClientConnectRequest")
	proto.RegisterType((*ClientConnectResponse)(nil), "atomix.service.ClientConnectResponse")
	proto.RegisterType((*ClientKeepAliveRequest)(nil), "atomix.service.ClientKeepAliveRequest")
	proto.RegisterType((*ClientState)(nil), "atomix.service.ClientState")
	proto.RegisterType((*SessionState)(nil), "atomix.service.SessionState")
	proto.RegisterType((*StreamState)(nil), "atomix.service.StreamState")
	proto.RegisterType((*ClientKeepAliveResponse)(nil), "atomix.service.ClientKeepAliveResponse")
	proto.RegisterType((*ClientCloseRequest)(nil), "atomix.service.ClientCloseRequest")
	proto.RegisterType((*ClientCloseResponse)(nil), "atomix.service.ClientCloseResponse")
	proto.RegisterType((*ClientCommandRequest)(nil), "atomix.service.ClientCommandRequest")
	proto.RegisterType((*ClientCommandResponse)(nil), "atomix.service.ClientCommandResponse")
	proto.RegisterType((*SessionOpenRequest)(nil), "atomix.service.SessionOpenRequest")
	proto.RegisterType((*SessionOpenResponse)(nil), "atomix.service.SessionOpenResponse")
	proto.RegisterType((*SessionCloseRequest)(nil), "atomix.service.SessionCloseRequest")
	proto.RegisterType((*SessionCloseResponse)(nil), "atomix.service.SessionCloseResponse")
	proto.RegisterType((*SessionCommandRequest)(nil), "atomix.service.SessionCommandRequest")
	proto.RegisterType((*SessionCommandResponse)(nil), "atomix.service.SessionCommandResponse")
	proto.RegisterType((*PartitionQueryRequest)(nil), "atomix.service.PartitionQueryRequest")
	proto.RegisterType((*PartitionQueryResponse)(nil), "atomix.service.PartitionQueryResponse")
	proto.RegisterType((*StateMachineQueryRequest)(nil), "atomix.service.StateMachineQueryRequest")
	proto.RegisterType((*StateMachineQueryResponse)(nil), "atomix.service.StateMachineQueryResponse")
	proto.RegisterType((*ClientQueryRequest)(nil), "atomix.service.ClientQueryRequest")
	proto.RegisterType((*ClientQueryResponse)(nil), "atomix.service.ClientQueryResponse")
	proto.RegisterType((*SessionQueryRequest)(nil), "atomix.service.SessionQueryRequest")
	proto.RegisterType((*SessionQueryResponse)(nil), "atomix.service.SessionQueryResponse")
	proto.RegisterType((*OperationRequest)(nil), "atomix.service.OperationRequest")
	proto.RegisterType((*OperationResponse)(nil), "atomix.service.OperationResponse")
	proto.RegisterType((*ResponseStatus)(nil), "atomix.service.ResponseStatus")
}

func init() {
	proto.RegisterFile("atomix/storage/protocol/rsm4/service.proto", fileDescriptor_2862b69821520282)
}

var fileDescriptor_2862b69821520282 = []byte{
	// 1977 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0xf2, 0x43, 0xd2, 0x3e, 0x7e, 0x68, 0x3d, 0x91, 0x15, 0x5a, 0x36, 0x48, 0x75, 0x13,
	0x3b, 0x8a, 0x0b, 0x48, 0x86, 0xdb, 0xa2, 0x2d, 0xda, 0x06, 0x25, 0x45, 0xda, 0xa2, 0x45, 0x91,
	0xf2, 0x8a, 0x74, 0xd3, 0x22, 0xa8, 0xb0, 0xe1, 0x8e, 0x19, 0x22, 0xe4, 0x2e, 0xc3, 0x5d, 0xba,
	0xf1, 0xbd, 0xb7, 0xa2, 0x40, 0x50, 0xa0, 0x40, 0x8a, 0x5e, 0x82, 0x22, 0xe8, 0x9f, 0xd0, 0x6b,
	0x81, 0x9e, 0x72, 0xcc, 0xb1, 0xc8, 0x41, 0x2d, 0x68, 0x14, 0xbd, 0xf4, 0xd4, 0x63, 0x4e, 0xc5,
	0x7c, 0xec, 0xee, 0xec, 0x17, 0x19, 0x4b, 0x32, 0xd0, 0x93, 0xb8, 0x33, 0xef, 0xfd, 0xe6, 0xcd,
	0xef, 0xbd, 0x79, 0xef, 0xcd, 0x08, 0xee, 0xea, 0x8e, 0x35, 0x1e, 0x7e, 0xbc, 0x6f, 0x3b, 0xd6,
	0x54, 0x1f, 0xe0, 0xfd, 0xc9, 0xd4, 0x72, 0xac, 0xbe, 0x35, 0xda, 0x9f, 0xda, 0xe3, 0xef, 0xee,
	0xdb, 0x78, 0xfa, 0x6c, 0xd8, 0xc7, 0x7b, 0x74, 0x14, 0x15, 0x99, 0xec, 0x1e, 0x1f, 0xdd, 0x2e,
	0x0f, 0x2c, 0x6b, 0x30, 0xe2, 0x3a, 0xef, 0xcf, 0x9e, 0xee, 0x1b, 0xb3, 0xa9, 0xee, 0x0c, 0x2d,
	0x93, 0xc9, 0x6f, 0x57, 0xc2, 0xf3, 0xce, 0x70, 0x8c, 0x6d, 0x47, 0x1f, 0x4f, 0xb8, 0xc0, 0xe6,
	0xc0, 0x1a, 0x58, 0xf4, 0xe7, 0x3e, 0xf9, 0xc5, 0x46, 0xd5, 0xff, 0x4a, 0xb0, 0x79, 0xea, 0xe8,
	0x0e, 0x3e, 0xd6, 0xfb, 0x1f, 0x0c, 0x4d, 0x7c, 0x6a, 0xea, 0x13, 0xfb, 0x03, 0xcb, 0x41, 0x15,
	0xc8, 0x0e, 0x4d, 0x03, 0x7f, 0x5c, 0x92, 0x76, 0xa4, 0xdd, 0x4c, 0x4d, 0xfe, 0xfa, 0xbc, 0x92,
	0x6d, 0x92, 0x01, 0x8d, 0x8d, 0xa3, 0x1a, 0xc8, 0xde, 0x12, 0xa5, 0xd4, 0x8e, 0xb4, 0x9b, 0xbb,
	0xbf, 0xbd, 0xc7, 0x8c, 0xd8, 0x73, 0x8d, 0xd8, 0xeb, 0xba, 0x12, 0xb5, 0xf5, 0x2f, 0xce, 0x2b,
	0x2b, 0x9f, 0xfc, 0xa3, 0x22, 0x69, 0xbe, 0x1a, 0xfa, 0x01, 0xac, 0xf5, 0x47, 0x43, 0x6c, 0x3a,
	0x76, 0x29, 0xbd, 0x93, 0xde, 0xcd, 0xdd, 0x2f, 0xef, 0x05, 0xb7, 0xbd, 0x77, 0x40, 0xa7, 0x5d,
	0xab, 0x34, 0x57, 0x1c, 0xfd, 0x08, 0xd6, 0xb9, 0x88, 0x5d, 0xca, 0x50, 0xd5, 0x4a, 0x58, 0xf5,
	0x94, 0xfd, 0xf5, 0x74, 0x3d, 0x05, 0xf5, 0x8f, 0x29, 0x28, 0x06, 0x81, 0xd1, 0xf7, 0x40, 0x66,
	0xd0, 0x67, 0x43, 0x83, 0x6f, 0xb9, 0x34, 0x3f, 0xaf, 0xac, 0x33, 0xb1, 0x66, 0xfd, 0x6b, 0xe1,
	0xb7, 0xb6, 0xce, 0x44, 0x9b, 0x06, 0x6a, 0xc1, 0x86, 0x8d, 0x6d, 0x7b, 0x68, 0x99, 0x67, 0x64,
	0x57, 0xd6, 0xcc, 0xe1, 0x54, 0xdc, 0x88, 0x50, 0x51, 0xe7, 0xfe, 0x62, 0x4c, 0x7c, 0x4a, 0x98,
	0x28, 0x72, 0xdd, 0x2e, 0x53, 0x45, 0x0f, 0x21, 0x3f, 0xd2, 0x6d, 0xe7, 0x6c, 0x36, 0x31, 0x74,
	0x07, 0x1b, 0xa5, 0xf4, 0x4b, 0xb0, 0x9a, 0x23, 0x9a, 0x3d, 0xa6, 0xc8, 0xd8, 0xa1, 0xd0, 0x0b,
	0xd8, 0xa1, 0xf3, 0x22, 0x3b, 0x4c, 0x41, 0xfd, 0x77, 0x1a, 0x36, 0x42, 0xb3, 0xe8, 0x5d, 0x00,
	0xae, 0xe8, 0xf2, 0x43, 0xb6, 0x18, 0x4f, 0x78, 0xd3, 0xa8, 0x95, 0x89, 0x59, 0xf3, 0xf3, 0x8a,
	0xec, 0x0e, 0x11, 0xfe, 0xfc, 0x0f, 0x4d, 0xb6, 0x5d, 0x51, 0xf4, 0x43, 0x82, 0xcc, 0x18, 0x1c,
	0x1a, 0x94, 0xbc, 0x4c, 0x6d, 0x9b, 0xa9, 0xd2, 0x51, 0x57, 0x95, 0x7f, 0x10, 0x55, 0xf6, 0xd3,
	0x40, 0x0f, 0x60, 0x83, 0xd2, 0x35, 0xc5, 0x1f, 0xcd, 0xb0, 0x4d, 0x3d, 0x97, 0xa6, 0xfa, 0xe5,
	0xf9, 0x79, 0xa5, 0xd0, 0xd2, 0x6d, 0x47, 0x63, 0x33, 0x0c, 0xc3, 0xfb, 0xd0, 0x0a, 0x23, 0x61,
	0xce, 0x40, 0x27, 0xa0, 0x4c, 0xb0, 0x69, 0x0c, 0xcd, 0x81, 0x0b, 0xe5, 0xb2, 0x76, 0x3b, 0x81,
	0xb5, 0x03, 0x6b, 0x3c, 0xd6, 0x4d, 0x83, 0x43, 0x68, 0x1b, 0x5c, 0x9d, 0x7f, 0xdb, 0xe8, 0x14,
	0xae, 0xf9, 0x88, 0xf6, 0xc4, 0x32, 0x6d, 0x6c, 0x97, 0xb2, 0x14, 0xf2, 0xce, 0x32, 0x48, 0x26,
	0xae, 0x29, 0x1e, 0x26, 0xd7, 0x27, 0x66, 0xba, 0x60, 0x67, 0xb6, 0x33, 0xc5, 0xfa, 0xd8, 0x2e,
	0xad, 0x2e, 0x34, 0xf3, 0x94, 0x4a, 0x79, 0x2e, 0xde, 0x70, 0xd5, 0xd9, 0xb8, 0xad, 0xfe, 0x25,
	0x05, 0xd7, 0x63, 0x45, 0x89, 0x57, 0x04, 0x56, 0x25, 0xdf, 0x2b, 0x09, 0x8c, 0xca, 0x53, 0x8f,
	0xcd, 0x2a, 0xe4, 0xad, 0x09, 0x66, 0xb1, 0xee, 0xba, 0xb4, 0x40, 0x5d, 0x92, 0xeb, 0xb8, 0xe3,
	0x54, 0x5d, 0xfc, 0xd4, 0x72, 0x9e, 0x4e, 0xd3, 0x40, 0x8f, 0x40, 0xe1, 0x8e, 0xe5, 0xdb, 0xf5,
	0x3c, 0xbb, 0x33, 0x3f, 0xaf, 0x14, 0x99, 0x67, 0xd9, 0x14, 0x45, 0x02, 0xff, 0x4b, 0x2b, 0x8e,
	0xc4, 0x59, 0x23, 0xde, 0x15, 0x99, 0xcb, 0xb9, 0x42, 0xfd, 0x4c, 0x22, 0x47, 0x24, 0x90, 0x5e,
	0x5e, 0xe1, 0x11, 0xf1, 0x52, 0x71, 0x2a, 0x21, 0x15, 0x23, 0xc8, 0x18, 0xba, 0xa3, 0x53, 0x8e,
	0xf2, 0x1a, 0xfd, 0xad, 0x1e, 0x83, 0x07, 0x66, 0x10, 0x01, 0xe7, 0xf9, 0x04, 0x53, 0xab, 0x64,
	0x8d, 0xfe, 0x46, 0x25, 0x92, 0x7b, 0x67, 0xb6, 0x83, 0xa7, 0x14, 0x57, 0xd6, 0xdc, 0x4f, 0x22,
	0x6d, 0xea, 0x63, 0x4c, 0xe1, 0x64, 0x8d, 0xfe, 0x56, 0x5b, 0xb0, 0x75, 0xa2, 0x4f, 0x9d, 0xa1,
	0x43, 0xf9, 0x31, 0x9f, 0x0e, 0xdd, 0x60, 0x47, 0xf7, 0x21, 0x3f, 0x71, 0x67, 0xdc, 0x9d, 0x17,
	0x6a, 0x1b, 0xc4, 0xdf, 0x9e, 0x06, 0x71, 0xb0, 0x27, 0xd4, 0x34, 0xd4, 0x0e, 0xbc, 0x1e, 0x41,
	0x63, 0xdc, 0xa2, 0x2d, 0x58, 0x1d, 0x61, 0xdd, 0xc0, 0x53, 0x6e, 0x2c, 0xff, 0x42, 0xb7, 0x40,
	0x7e, 0x6a, 0x8d, 0x46, 0xd6, 0xaf, 0xf0, 0xd4, 0x2e, 0xa5, 0x76, 0xd2, 0xbb, 0xb2, 0xe6, 0x0f,
	0xa8, 0x7f, 0x90, 0x02, 0x88, 0xe2, 0xe9, 0xbc, 0x88, 0x81, 0xe8, 0x11, 0xac, 0xf1, 0x88, 0xe6,
	0xf9, 0xfc, 0x6e, 0xc4, 0x93, 0x42, 0xd1, 0x0c, 0x2e, 0x58, 0xcb, 0x10, 0xd7, 0x6a, 0x2e, 0x80,
	0x3a, 0x84, 0x52, 0xd4, 0x34, 0xbe, 0xdb, 0x63, 0x58, 0x77, 0xa3, 0x92, 0x87, 0xcc, 0xb7, 0xbf,
	0xd1, 0x42, 0x4c, 0x85, 0xaf, 0xe4, 0x41, 0xa8, 0x9f, 0xa7, 0x61, 0x3b, 0xd9, 0x30, 0xf4, 0x8e,
	0x58, 0xb2, 0xa5, 0xa5, 0xc5, 0x25, 0x13, 0x2e, 0xd7, 0xc7, 0x50, 0xe4, 0x45, 0xb2, 0x6f, 0x99,
	0x26, 0xee, 0xbb, 0xe4, 0xbc, 0x19, 0x5f, 0xb5, 0x0f, 0x98, 0x10, 0x5f, 0xfd, 0x70, 0x45, 0x2b,
	0xf4, 0xc5, 0x71, 0xd4, 0x85, 0x6b, 0x1c, 0xee, 0x43, 0x8c, 0x27, 0x67, 0xfa, 0x68, 0xf8, 0x0c,
	0xf3, 0x9a, 0x77, 0x27, 0x1e, 0xf1, 0x08, 0xe3, 0x49, 0x95, 0x88, 0xf9, 0x98, 0x1b, 0xfd, 0xe0,
	0x0c, 0x29, 0xa2, 0xae, 0x91, 0x23, 0xcb, 0xc6, 0xa5, 0x0c, 0x05, 0x54, 0x13, 0x4c, 0x24, 0x22,
	0x3e, 0x58, 0xae, 0xef, 0x8f, 0x06, 0x76, 0x4b, 0x69, 0x2c, 0x65, 0x17, 0xef, 0x56, 0xe4, 0x5a,
	0xdc, 0x2d, 0x1d, 0xaf, 0xc9, 0x5e, 0x48, 0xa9, 0xbf, 0x49, 0xc3, 0xcd, 0x05, 0x6e, 0x5d, 0xde,
	0x7b, 0xb5, 0x13, 0x1c, 0x71, 0x7b, 0x89, 0x23, 0x18, 0x7e, 0xd4, 0x13, 0xbd, 0x64, 0x4f, 0xbc,
	0xb5, 0xd4, 0x13, 0x1e, 0x68, 0xc4, 0x15, 0x87, 0xb1, 0xae, 0x78, 0x63, 0xa1, 0x2b, 0x3c, 0xb4,
	0x80, 0x2f, 0xda, 0x09, 0xbe, 0xb8, 0xbd, 0xc4, 0x17, 0xd1, 0x0d, 0x33, 0x67, 0x80, 0x7f, 0xee,
	0x54, 0x03, 0x36, 0xe3, 0xe2, 0xf5, 0x6a, 0x7b, 0x3b, 0xb5, 0x0d, 0xd7, 0x63, 0x9d, 0x71, 0xc1,
	0xce, 0x53, 0x7d, 0x0c, 0x5b, 0xf1, 0x67, 0x02, 0x7d, 0x1f, 0xb2, 0x36, 0x09, 0x2e, 0x7e, 0xc2,
	0x6f, 0x26, 0xb4, 0xd4, 0x44, 0x84, 0x27, 0x10, 0x26, 0xaf, 0xfe, 0x5a, 0x82, 0x9c, 0x30, 0x79,
	0xd1, 0x9e, 0xf8, 0x1d, 0xa1, 0xf9, 0x4c, 0xd1, 0x42, 0x7b, 0x2b, 0xb1, 0x3f, 0xf1, 0x6d, 0xf0,
	0xfb, 0xcf, 0xbf, 0x49, 0x90, 0x17, 0x05, 0x42, 0x2d, 0xa2, 0xf4, 0x32, 0x2d, 0xe2, 0xdb, 0x31,
	0xad, 0x5d, 0x8a, 0x56, 0xc9, 0x48, 0xcf, 0xd6, 0x8a, 0x69, 0xaf, 0xd8, 0xa5, 0xe4, 0x66, 0x34,
	0x25, 0xd3, 0x66, 0x49, 0xb0, 0x3e, 0xd2, 0x5a, 0x7d, 0x26, 0x41, 0x4e, 0x10, 0xbb, 0x4c, 0x43,
	0xf5, 0x04, 0x36, 0xfb, 0xd6, 0x78, 0x32, 0xc2, 0x0e, 0x0e, 0x74, 0x44, 0xac, 0x1b, 0x78, 0x73,
	0x7e, 0x5e, 0x41, 0x07, 0x7c, 0x3e, 0xb1, 0x2b, 0x42, 0xfd, 0xb0, 0x84, 0xa1, 0xde, 0x80, 0xd7,
	0x13, 0xce, 0xb2, 0x7a, 0x04, 0x28, 0x9a, 0x1f, 0x2f, 0x1a, 0xa9, 0xd7, 0xe1, 0xb5, 0x98, 0x13,
	0xae, 0xfe, 0x35, 0xe5, 0x9f, 0xbb, 0x40, 0x95, 0xba, 0x60, 0xd8, 0x3d, 0x84, 0xbc, 0x1b, 0x25,
	0xd6, 0x04, 0x9b, 0xfc, 0xac, 0xaa, 0x09, 0xa1, 0xd7, 0x99, 0x60, 0x53, 0xc8, 0xfb, 0xb6, 0x3f,
	0x8a, 0x1e, 0x41, 0xc1, 0x05, 0x62, 0x69, 0x2b, 0x1d, 0x9f, 0xb6, 0xdc, 0x6e, 0x31, 0x58, 0x42,
	0x5c, 0x23, 0x58, 0xde, 0x3a, 0xf1, 0x73, 0x88, 0x9b, 0xb8, 0x32, 0xf1, 0x89, 0x2b, 0xf6, 0x66,
	0x71, 0xb8, 0xe2, 0xe5, 0x91, 0x98, 0x32, 0xf2, 0xdb, 0x94, 0x9f, 0x53, 0x82, 0x05, 0xe4, 0x30,
	0xc4, 0x85, 0xb4, 0x70, 0x07, 0x8c, 0x0b, 0x3f, 0xf1, 0x8a, 0x64, 0x1c, 0x85, 0xc9, 0x48, 0xa8,
	0xf8, 0x41, 0x32, 0x3c, 0xac, 0x20, 0x1b, 0x8f, 0xa3, 0x6c, 0x24, 0x94, 0xfb, 0xf8, 0x4e, 0x3c,
	0x86, 0x0e, 0x31, 0x91, 0x9b, 0x80, 0xa2, 0xde, 0x7d, 0x75, 0x7d, 0xb9, 0x7a, 0x02, 0xaf, 0xc5,
	0x30, 0x78, 0x89, 0x74, 0x25, 0x20, 0x06, 0x0e, 0xde, 0x25, 0x10, 0xb7, 0x60, 0x33, 0xce, 0x35,
	0xea, 0x57, 0x92, 0x77, 0xf5, 0x0b, 0x1d, 0xbf, 0x4b, 0x64, 0xdb, 0x60, 0x92, 0x4b, 0xbd, 0x4c,
	0x92, 0xfb, 0x29, 0xc8, 0xde, 0x0d, 0x90, 0x07, 0xc5, 0x4e, 0xd8, 0x49, 0xde, 0x7d, 0xd1, 0x3f,
	0x1d, 0xbe, 0x92, 0x78, 0x30, 0xfe, 0x2c, 0xc1, 0x56, 0x7c, 0x04, 0xa1, 0x9f, 0x40, 0x4e, 0xcc,
	0xa1, 0x6c, 0x7b, 0xb7, 0xe6, 0x81, 0x6c, 0x19, 0xca, 0x9d, 0x30, 0xf5, 0x6f, 0x93, 0x55, 0xd1,
	0x4c, 0x76, 0x14, 0xbe, 0xb5, 0xc0, 0x4c, 0x2f, 0x6c, 0x05, 0x3b, 0xc5, 0x88, 0xfd, 0xbd, 0x04,
	0xd7, 0xbd, 0xbb, 0xc1, 0xe3, 0x19, 0x9e, 0x3e, 0xbf, 0xcc, 0xa5, 0xe5, 0x30, 0x7c, 0x69, 0xd9,
	0x5d, 0x74, 0x97, 0x10, 0x97, 0x0b, 0x5f, 0x59, 0xb0, 0x70, 0xdb, 0xe3, 0x72, 0x9c, 0xbf, 0xa3,
	0xc8, 0x85, 0xe5, 0xed, 0x6f, 0xb0, 0x48, 0xc2, 0x75, 0xe5, 0x53, 0x09, 0x4a, 0x49, 0x26, 0xa1,
	0x5d, 0x00, 0xfb, 0xb9, 0xd9, 0x3f, 0x4b, 0xe8, 0x84, 0x65, 0x32, 0x49, 0x7f, 0x0a, 0x1d, 0xff,
	0x47, 0x04, 0x20, 0x29, 0xf3, 0xb3, 0x54, 0x29, 0xae, 0xe1, 0x77, 0x99, 0x74, 0x54, 0x0c, 0xa1,
	0xdf, 0x49, 0x70, 0x23, 0x71, 0x23, 0xcb, 0x1b, 0xf4, 0xc3, 0x58, 0x93, 0xde, 0x58, 0x68, 0x52,
	0xb8, 0xf3, 0x65, 0x36, 0x89, 0xe1, 0xf2, 0x27, 0xc9, 0xad, 0xcb, 0x01, 0xa6, 0x2e, 0x58, 0x30,
	0x85, 0x3a, 0xb7, 0xd0, 0x48, 0x7e, 0x92, 0x42, 0xc4, 0xb9, 0x99, 0x3d, 0xc2, 0x9c, 0xe9, 0x96,
	0xfb, 0x70, 0xe0, 0x84, 0x56, 0x93, 0x16, 0x16, 0x92, 0x30, 0x27, 0xc1, 0xe5, 0x44, 0x52, 0xfe,
	0x25, 0x79, 0x49, 0x33, 0xc0, 0xca, 0x25, 0xf2, 0x58, 0xcc, 0xc3, 0x62, 0xea, 0x22, 0x0f, 0x8b,
	0x57, 0x9a, 0xd4, 0x3e, 0x97, 0xbc, 0x54, 0x1e, 0x64, 0xf6, 0xff, 0x2b, 0xa5, 0x7d, 0x08, 0x4a,
	0x78, 0x4b, 0x91, 0x27, 0x41, 0xe9, 0xe5, 0x9f, 0x04, 0x37, 0x21, 0xfb, 0x4c, 0x1f, 0xcd, 0x30,
	0xef, 0xde, 0xd9, 0x87, 0x3a, 0x80, 0x6b, 0x11, 0xd3, 0xd0, 0x8f, 0x61, 0x95, 0xdc, 0x67, 0x66,
	0x36, 0x0f, 0xb1, 0xc8, 0xff, 0x14, 0x34, 0xaf, 0x57, 0x27, 0x52, 0x3c, 0x2b, 0x71, 0x9d, 0x84,
	0x85, 0x1c, 0x28, 0x06, 0xb5, 0xd0, 0x3d, 0xc8, 0xf4, 0x2d, 0x83, 0x25, 0xc1, 0x62, 0xf4, 0x86,
	0xe3, 0x4a, 0x1f, 0x58, 0x06, 0xd6, 0xa8, 0x24, 0x2a, 0xc1, 0xda, 0x18, 0xdb, 0xb6, 0x3e, 0xc0,
	0xee, 0x83, 0x1b, 0xff, 0x14, 0xde, 0xbc, 0xd2, 0xe2, 0x9b, 0xd7, 0xdd, 0xaf, 0x24, 0xc8, 0x8b,
	0x40, 0x68, 0x15, 0x52, 0x9d, 0x23, 0x65, 0x05, 0xc9, 0x90, 0x6d, 0x68, 0x5a, 0x47, 0x53, 0x24,
	0x94, 0x83, 0xb5, 0x5e, 0xfb, 0xa8, 0xdd, 0xf9, 0x59, 0x5b, 0x49, 0xa1, 0x3c, 0xac, 0x1f, 0x54,
	0xdb, 0x07, 0x8d, 0x56, 0xa3, 0xae, 0xa4, 0x51, 0x01, 0xe4, 0x76, 0xa7, 0x7b, 0xf6, 0xa0, 0xd3,
	0x6b, 0xd7, 0x95, 0x0c, 0x42, 0x50, 0xac, 0xb6, 0xb4, 0x46, 0xb5, 0xfe, 0xf3, 0xb3, 0xc6, 0xbb,
	0xcd, 0xd3, 0xee, 0xa9, 0x92, 0x45, 0x0a, 0xe4, 0x7b, 0xed, 0x6a, 0xaf, 0x7b, 0xd8, 0xd1, 0x9a,
	0xbf, 0x68, 0xd4, 0x95, 0x55, 0xa2, 0xf4, 0xa0, 0xa3, 0xd5, 0x9a, 0xf5, 0x7a, 0xa3, 0xad, 0xac,
	0x51, 0xc4, 0x4e, 0xfb, 0x41, 0xab, 0x79, 0xd0, 0x55, 0xd6, 0xc9, 0x62, 0xcd, 0xf6, 0x93, 0x6a,
	0xab, 0x59, 0x57, 0x64, 0xb4, 0x01, 0xb9, 0x5e, 0xbb, 0xfa, 0xa4, 0xda, 0x6c, 0x55, 0x6b, 0xad,
	0x86, 0x02, 0xe8, 0x1a, 0x14, 0xc8, 0x7a, 0xa7, 0xbd, 0x93, 0x93, 0x8e, 0xd6, 0x6d, 0xd4, 0x95,
	0x1c, 0x51, 0xe8, 0x36, 0x8f, 0x1b, 0x9d, 0x5e, 0x57, 0xc9, 0x13, 0xac, 0x66, 0xbb, 0xdb, 0xd0,
	0xda, 0xd5, 0x96, 0x52, 0xb8, 0xff, 0x9f, 0x34, 0x28, 0x5e, 0x91, 0xe1, 0xfd, 0x15, 0x7a, 0x0f,
	0xe4, 0x87, 0xd8, 0x61, 0x4f, 0x82, 0x28, 0xd2, 0x15, 0xc6, 0xbf, 0x40, 0x6e, 0xbf, 0xb5, 0x54,
	0x8e, 0x47, 0xc6, 0x13, 0xc8, 0xd2, 0xa3, 0x83, 0x6e, 0x27, 0x6a, 0x88, 0x29, 0x64, 0xfb, 0xce,
	0x32, 0x31, 0x8e, 0xfb, 0x4b, 0xc8, 0xd1, 0x01, 0x76, 0xe1, 0xbb, 0x62, 0xf4, 0x7b, 0x12, 0x7a,
	0x0f, 0xd6, 0x78, 0x1f, 0x83, 0x16, 0xed, 0x55, 0x6c, 0xe3, 0xb6, 0x77, 0x97, 0x0b, 0x72, 0xeb,
	0x0d, 0x28, 0xf0, 0x21, 0x6e, 0xff, 0xd5, 0xaf, 0x71, 0x4f, 0xaa, 0x95, 0xbe, 0x98, 0x97, 0xa5,
	0x2f, 0xe7, 0x65, 0xe9, 0x9f, 0xf3, 0xb2, 0xf4, 0xc9, 0x8b, 0xf2, 0xca, 0x97, 0x2f, 0xca, 0x2b,
	0x7f, 0x7f, 0x51, 0x5e, 0x79, 0x7f, 0x95, 0x3e, 0xa3, 0x7c, 0xe7, 0x7f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x0c, 0x07, 0x01, 0x92, 0x1e, 0x1d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PartitionServiceClient is the client API for PartitionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PartitionServiceClient interface {
	GetConfig(ctx context.Context, in *PartitionConfigRequest, opts ...grpc.CallOption) (*PartitionConfigResponse, error)
	Query(ctx context.Context, in *PartitionQueryRequest, opts ...grpc.CallOption) (*PartitionQueryResponse, error)
	QueryStream(ctx context.Context, in *PartitionQueryRequest, opts ...grpc.CallOption) (PartitionService_QueryStreamClient, error)
	Command(ctx context.Context, in *PartitionCommandRequest, opts ...grpc.CallOption) (*PartitionCommandResponse, error)
	CommandStream(ctx context.Context, in *PartitionCommandRequest, opts ...grpc.CallOption) (PartitionService_CommandStreamClient, error)
}

type partitionServiceClient struct {
	cc *grpc.ClientConn
}

func NewPartitionServiceClient(cc *grpc.ClientConn) PartitionServiceClient {
	return &partitionServiceClient{cc}
}

func (c *partitionServiceClient) GetConfig(ctx context.Context, in *PartitionConfigRequest, opts ...grpc.CallOption) (*PartitionConfigResponse, error) {
	out := new(PartitionConfigResponse)
	err := c.cc.Invoke(ctx, "/atomix.service.PartitionService/GetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *partitionServiceClient) Query(ctx context.Context, in *PartitionQueryRequest, opts ...grpc.CallOption) (*PartitionQueryResponse, error) {
	out := new(PartitionQueryResponse)
	err := c.cc.Invoke(ctx, "/atomix.service.PartitionService/Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *partitionServiceClient) QueryStream(ctx context.Context, in *PartitionQueryRequest, opts ...grpc.CallOption) (PartitionService_QueryStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PartitionService_serviceDesc.Streams[0], "/atomix.service.PartitionService/QueryStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &partitionServiceQueryStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PartitionService_QueryStreamClient interface {
	Recv() (*PartitionQueryResponse, error)
	grpc.ClientStream
}

type partitionServiceQueryStreamClient struct {
	grpc.ClientStream
}

func (x *partitionServiceQueryStreamClient) Recv() (*PartitionQueryResponse, error) {
	m := new(PartitionQueryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *partitionServiceClient) Command(ctx context.Context, in *PartitionCommandRequest, opts ...grpc.CallOption) (*PartitionCommandResponse, error) {
	out := new(PartitionCommandResponse)
	err := c.cc.Invoke(ctx, "/atomix.service.PartitionService/Command", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *partitionServiceClient) CommandStream(ctx context.Context, in *PartitionCommandRequest, opts ...grpc.CallOption) (PartitionService_CommandStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PartitionService_serviceDesc.Streams[1], "/atomix.service.PartitionService/CommandStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &partitionServiceCommandStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PartitionService_CommandStreamClient interface {
	Recv() (*PartitionCommandResponse, error)
	grpc.ClientStream
}

type partitionServiceCommandStreamClient struct {
	grpc.ClientStream
}

func (x *partitionServiceCommandStreamClient) Recv() (*PartitionCommandResponse, error) {
	m := new(PartitionCommandResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PartitionServiceServer is the server API for PartitionService service.
type PartitionServiceServer interface {
	GetConfig(context.Context, *PartitionConfigRequest) (*PartitionConfigResponse, error)
	Query(context.Context, *PartitionQueryRequest) (*PartitionQueryResponse, error)
	QueryStream(*PartitionQueryRequest, PartitionService_QueryStreamServer) error
	Command(context.Context, *PartitionCommandRequest) (*PartitionCommandResponse, error)
	CommandStream(*PartitionCommandRequest, PartitionService_CommandStreamServer) error
}

// UnimplementedPartitionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedPartitionServiceServer struct {
}

func (*UnimplementedPartitionServiceServer) GetConfig(ctx context.Context, req *PartitionConfigRequest) (*PartitionConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (*UnimplementedPartitionServiceServer) Query(ctx context.Context, req *PartitionQueryRequest) (*PartitionQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (*UnimplementedPartitionServiceServer) QueryStream(req *PartitionQueryRequest, srv PartitionService_QueryStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method QueryStream not implemented")
}
func (*UnimplementedPartitionServiceServer) Command(ctx context.Context, req *PartitionCommandRequest) (*PartitionCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Command not implemented")
}
func (*UnimplementedPartitionServiceServer) CommandStream(req *PartitionCommandRequest, srv PartitionService_CommandStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method CommandStream not implemented")
}

func RegisterPartitionServiceServer(s *grpc.Server, srv PartitionServiceServer) {
	s.RegisterService(&_PartitionService_serviceDesc, srv)
}

func _PartitionService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartitionConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.service.PartitionService/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).GetConfig(ctx, req.(*PartitionConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PartitionService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartitionQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.service.PartitionService/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).Query(ctx, req.(*PartitionQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PartitionService_QueryStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PartitionQueryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PartitionServiceServer).QueryStream(m, &partitionServiceQueryStreamServer{stream})
}

type PartitionService_QueryStreamServer interface {
	Send(*PartitionQueryResponse) error
	grpc.ServerStream
}

type partitionServiceQueryStreamServer struct {
	grpc.ServerStream
}

func (x *partitionServiceQueryStreamServer) Send(m *PartitionQueryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PartitionService_Command_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartitionCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).Command(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.service.PartitionService/Command",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).Command(ctx, req.(*PartitionCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PartitionService_CommandStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PartitionCommandRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PartitionServiceServer).CommandStream(m, &partitionServiceCommandStreamServer{stream})
}

type PartitionService_CommandStreamServer interface {
	Send(*PartitionCommandResponse) error
	grpc.ServerStream
}

type partitionServiceCommandStreamServer struct {
	grpc.ServerStream
}

func (x *partitionServiceCommandStreamServer) Send(m *PartitionCommandResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _PartitionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "atomix.service.PartitionService",
	HandlerType: (*PartitionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfig",
			Handler:    _PartitionService_GetConfig_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _PartitionService_Query_Handler,
		},
		{
			MethodName: "Command",
			Handler:    _PartitionService_Command_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "QueryStream",
			Handler:       _PartitionService_QueryStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CommandStream",
			Handler:       _PartitionService_CommandStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "atomix/storage/protocol/rsm4/service.proto",
}

func (m *StateMachineSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Clients) > 0 {
		for iNdEx := len(m.Clients) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clients[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintService(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x12
	if m.Index != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUpdated, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdated):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintService(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x1a
	n3, err3 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.SessionTimeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.SessionTimeout):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintService(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x12
	if m.ClientID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.ClientID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponseStreams) > 0 {
		for iNdEx := len(m.ResponseStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PendingResponses) > 0 {
		for iNdEx := len(m.PendingResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PendingRequests) > 0 {
		for iNdEx := len(m.PendingRequests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingRequests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LastRequestID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.LastRequestID))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ServiceID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SessionStreamSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionStreamSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionStreamSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PendingResponses) > 0 {
		for iNdEx := len(m.PendingResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LastResponseID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.LastResponseID))
		i--
		dAtA[i] = 0x18
	}
	if m.OperationID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.OperationID))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintService(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ServiceID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ServiceId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintService(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintService(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PartitionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Followers) > 0 {
		for iNdEx := len(m.Followers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Followers[iNdEx])
			copy(dAtA[i:], m.Followers[iNdEx])
			i = encodeVarintService(dAtA, i, uint64(len(m.Followers[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintService(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionCommandRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionCommandRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionCommandRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PartitionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionCommandResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionCommandResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionCommandResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StateMachineCommandRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineCommandRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Timestamp != nil {
		n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Timestamp):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintService(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineCommandRequest_ClientConnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandRequest_ClientConnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientConnect != nil {
		{
			size, err := m.ClientConnect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineCommandRequest_ClientKeepAlive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandRequest_ClientKeepAlive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientKeepAlive != nil {
		{
			size, err := m.ClientKeepAlive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineCommandRequest_ClientClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandRequest_ClientClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientClose != nil {
		{
			size, err := m.ClientClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineCommandRequest_ClientCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandRequest_ClientCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientCommand != nil {
		{
			size, err := m.ClientCommand.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineCommandResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineCommandResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Index != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineCommandResponse_ClientConnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandResponse_ClientConnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientConnect != nil {
		{
			size, err := m.ClientConnect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineCommandResponse_ClientKeepAlive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandResponse_ClientKeepAlive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientKeepAlive != nil {
		{
			size, err := m.ClientKeepAlive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineCommandResponse_ClientClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandResponse_ClientClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientClose != nil {
		{
			size, err := m.ClientClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineCommandResponse_ClientCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineCommandResponse_ClientCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientCommand != nil {
		{
			size, err := m.ClientCommand.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ClientConnectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientConnectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientConnectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n17, err17 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.SessionTimeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.SessionTimeout):])
	if err17 != nil {
		return 0, err17
	}
	i -= n17
	i = encodeVarintService(dAtA, i, uint64(n17))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *ClientConnectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientConnectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientConnectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.ClientID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientKeepAliveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientKeepAliveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientKeepAliveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ClientID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.ClientID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponseStreams) > 0 {
		for iNdEx := len(m.ResponseStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PendingRequests) > 0 {
		i -= len(m.PendingRequests)
		copy(dAtA[i:], m.PendingRequests)
		i = encodeVarintService(dAtA, i, uint64(len(m.PendingRequests)))
		i--
		dAtA[i] = 0x12
	}
	if m.SessionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StreamState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompleteResponseID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.CompleteResponseID))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientKeepAliveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientKeepAliveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientKeepAliveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ClientCloseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCloseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCloseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.ClientID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientCloseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCloseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCloseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ClientCommandRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCommandRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCommandRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ClientID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.ClientID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientCommandRequest_SessionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCommandRequest_SessionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SessionOpen != nil {
		{
			size, err := m.SessionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ClientCommandRequest_SessionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCommandRequest_SessionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SessionClose != nil {
		{
			size, err := m.SessionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ClientCommandRequest_SessionCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCommandRequest_SessionCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SessionCommand != nil {
		{
			size, err := m.SessionCommand.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ClientCommandResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientCommandResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCommandResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClientCommandResponse_SessionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCommandResponse_SessionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SessionOpen != nil {
		{
			size, err := m.SessionOpen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ClientCommandResponse_SessionClose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCommandResponse_SessionClose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SessionClose != nil {
		{
			size, err := m.SessionClose.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ClientCommandResponse_SessionCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientCommandResponse_SessionCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SessionCommand != nil {
		{
			size, err := m.SessionCommand.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SessionOpenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionOpenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionOpenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ServiceID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SessionOpenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionOpenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionOpenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionCloseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionCloseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionCloseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionCloseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionCloseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionCloseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SessionCommandRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionCommandRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionCommandRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RequestID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x10
	}
	if m.SessionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionCommandRequest_Operation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionCommandRequest_Operation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Operation != nil {
		{
			size, err := m.Operation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SessionCommandResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionCommandResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionCommandResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ResponseID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.ResponseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionCommandResponse_Operation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionCommandResponse_Operation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Operation != nil {
		{
			size, err := m.Operation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PartitionQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PartitionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StateMachineQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SyncIndex != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SyncIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineQueryRequest_ClientQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineQueryRequest_ClientQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientQuery != nil {
		{
			size, err := m.ClientQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Index != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineQueryResponse_ClientQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineQueryResponse_ClientQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientQuery != nil {
		{
			size, err := m.ClientQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ClientQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ClientID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.ClientID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientQueryRequest_SessionQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientQueryRequest_SessionQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SessionQuery != nil {
		{
			size, err := m.SessionQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ClientQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClientQueryResponse_SessionQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientQueryResponse_SessionQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SessionQuery != nil {
		{
			size, err := m.SessionQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SessionQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LastRequestID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.LastRequestID))
		i--
		dAtA[i] = 0x10
	}
	if m.SessionID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionQueryRequest_Operation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionQueryRequest_Operation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Operation != nil {
		{
			size, err := m.Operation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SessionQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ResponseID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.ResponseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionQueryResponse_Operation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionQueryResponse_Operation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Operation != nil {
		{
			size, err := m.Operation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OperationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintService(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.OperationID != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.OperationID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintService(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResponseStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintService(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintService(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintService(dAtA []byte, offset int, v uint64) int {
	offset -= sovService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StateMachineSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovService(uint64(m.Index))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovService(uint64(l))
	if len(m.Clients) > 0 {
		for _, e := range m.Clients {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *ClientSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientID != 0 {
		n += 1 + sovService(uint64(m.ClientID))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.SessionTimeout)
	n += 1 + l + sovService(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdated)
	n += 1 + l + sovService(uint64(l))
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *SessionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ServiceID.Size()
	n += 1 + l + sovService(uint64(l))
	if m.SessionID != 0 {
		n += 1 + sovService(uint64(m.SessionID))
	}
	if m.LastRequestID != 0 {
		n += 1 + sovService(uint64(m.LastRequestID))
	}
	if len(m.PendingRequests) > 0 {
		for _, e := range m.PendingRequests {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	if len(m.PendingResponses) > 0 {
		for _, e := range m.PendingResponses {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	if len(m.ResponseStreams) > 0 {
		for _, e := range m.ResponseStreams {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *SessionStreamSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovService(uint64(m.RequestID))
	}
	if m.OperationID != 0 {
		n += 1 + sovService(uint64(m.OperationID))
	}
	if m.LastResponseID != 0 {
		n += 1 + sovService(uint64(m.LastResponseID))
	}
	if len(m.PendingResponses) > 0 {
		for _, e := range m.PendingResponses {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *ServiceSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ServiceID.Size()
	n += 1 + l + sovService(uint64(l))
	if m.Index != 0 {
		n += 1 + sovService(uint64(m.Index))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *ServiceId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *PartitionConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionID != 0 {
		n += 1 + sovService(uint64(m.PartitionID))
	}
	return n
}

func (m *PartitionConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	if len(m.Followers) > 0 {
		for _, s := range m.Followers {
			l = len(s)
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *PartitionCommandRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionID != 0 {
		n += 1 + sovService(uint64(m.PartitionID))
	}
	l = m.Request.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *PartitionCommandResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Response.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *StateMachineCommandRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Timestamp)
		n += 1 + l + sovService(uint64(l))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *StateMachineCommandRequest_ClientConnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientConnect != nil {
		l = m.ClientConnect.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *StateMachineCommandRequest_ClientKeepAlive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientKeepAlive != nil {
		l = m.ClientKeepAlive.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *StateMachineCommandRequest_ClientClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientClose != nil {
		l = m.ClientClose.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *StateMachineCommandRequest_ClientCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientCommand != nil {
		l = m.ClientCommand.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *StateMachineCommandResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovService(uint64(m.Index))
	}
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *StateMachineCommandResponse_ClientConnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientConnect != nil {
		l = m.ClientConnect.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *StateMachineCommandResponse_ClientKeepAlive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientKeepAlive != nil {
		l = m.ClientKeepAlive.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *StateMachineCommandResponse_ClientClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientClose != nil {
		l = m.ClientClose.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *StateMachineCommandResponse_ClientCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientCommand != nil {
		l = m.ClientCommand.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *ClientConnectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.SessionTimeout)
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *ClientConnectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientID != 0 {
		n += 1 + sovService(uint64(m.ClientID))
	}
	return n
}

func (m *ClientKeepAliveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.State.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientID != 0 {
		n += 1 + sovService(uint64(m.ClientID))
	}
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *SessionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovService(uint64(m.SessionID))
	}
	l = len(m.PendingRequests)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	if len(m.ResponseStreams) > 0 {
		for _, e := range m.ResponseStreams {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *StreamState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovService(uint64(m.RequestID))
	}
	if m.CompleteResponseID != 0 {
		n += 1 + sovService(uint64(m.CompleteResponseID))
	}
	return n
}

func (m *ClientKeepAliveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ClientCloseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientID != 0 {
		n += 1 + sovService(uint64(m.ClientID))
	}
	return n
}

func (m *ClientCloseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ClientCommandRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientID != 0 {
		n += 1 + sovService(uint64(m.ClientID))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *ClientCommandRequest_SessionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionOpen != nil {
		l = m.SessionOpen.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *ClientCommandRequest_SessionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionClose != nil {
		l = m.SessionClose.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *ClientCommandRequest_SessionCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionCommand != nil {
		l = m.SessionCommand.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *ClientCommandResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *ClientCommandResponse_SessionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionOpen != nil {
		l = m.SessionOpen.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *ClientCommandResponse_SessionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionClose != nil {
		l = m.SessionClose.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *ClientCommandResponse_SessionCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionCommand != nil {
		l = m.SessionCommand.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionOpenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ServiceID.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *SessionOpenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovService(uint64(m.SessionID))
	}
	return n
}

func (m *SessionCloseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovService(uint64(m.SessionID))
	}
	return n
}

func (m *SessionCloseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SessionCommandRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovService(uint64(m.SessionID))
	}
	if m.RequestID != 0 {
		n += 1 + sovService(uint64(m.RequestID))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *SessionCommandRequest_Operation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionCommandResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseID != 0 {
		n += 1 + sovService(uint64(m.ResponseID))
	}
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *SessionCommandResponse_Operation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *PartitionQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionID != 0 {
		n += 1 + sovService(uint64(m.PartitionID))
	}
	l = m.Request.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *PartitionQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Response.Size()
	n += 1 + l + sovService(uint64(l))
	return n
}

func (m *StateMachineQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SyncIndex != 0 {
		n += 1 + sovService(uint64(m.SyncIndex))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *StateMachineQueryRequest_ClientQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientQuery != nil {
		l = m.ClientQuery.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *StateMachineQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovService(uint64(m.Index))
	}
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *StateMachineQueryResponse_ClientQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientQuery != nil {
		l = m.ClientQuery.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *ClientQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientID != 0 {
		n += 1 + sovService(uint64(m.ClientID))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *ClientQueryRequest_SessionQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionQuery != nil {
		l = m.SessionQuery.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *ClientQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *ClientQueryResponse_SessionQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionQuery != nil {
		l = m.SessionQuery.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovService(uint64(m.SessionID))
	}
	if m.LastRequestID != 0 {
		n += 1 + sovService(uint64(m.LastRequestID))
	}
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *SessionQueryRequest_Operation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *SessionQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseID != 0 {
		n += 1 + sovService(uint64(m.ResponseID))
	}
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *SessionQueryResponse_Operation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}
func (m *OperationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationID != 0 {
		n += 1 + sovService(uint64(m.OperationID))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *OperationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Status.Size()
	n += 1 + l + sovService(uint64(l))
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *ResponseStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovService(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func sovService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozService(x uint64) (n int) {
	return sovService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StateMachineSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clients = append(m.Clients, &ClientSnapshot{})
			if err := m.Clients[len(m.Clients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &ServiceSnapshot{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= ClientID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.SessionTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUpdated, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &SessionSnapshot{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRequestID", wireType)
			}
			m.LastRequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingRequests = append(m.PendingRequests, &SessionCommandRequest{})
			if err := m.PendingRequests[len(m.PendingRequests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingResponses = append(m.PendingResponses, &SessionCommandResponse{})
			if err := m.PendingResponses[len(m.PendingResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseStreams = append(m.ResponseStreams, &SessionStreamSnapshot{})
			if err := m.ResponseStreams[len(m.ResponseStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionStreamSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionStreamSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionStreamSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationID", wireType)
			}
			m.OperationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationID |= OperationID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastResponseID", wireType)
			}
			m.LastResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastResponseID |= ResponseID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingResponses = append(m.PendingResponses, &SessionCommandResponse{})
			if err := m.PendingResponses[len(m.PendingResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Followers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Followers = append(m.Followers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionCommandRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionCommandRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionCommandRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionCommandResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionCommandResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionCommandResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineCommandRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineCommandRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineCommandRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientConnect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientConnectRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &StateMachineCommandRequest_ClientConnect{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKeepAlive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientKeepAliveRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &StateMachineCommandRequest_ClientKeepAlive{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCloseRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &StateMachineCommandRequest_ClientClose{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCommand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCommandRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &StateMachineCommandRequest_ClientCommand{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineCommandResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineCommandResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineCommandResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientConnect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientConnectResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &StateMachineCommandResponse_ClientConnect{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKeepAlive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientKeepAliveResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &StateMachineCommandResponse_ClientKeepAlive{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCloseResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &StateMachineCommandResponse_ClientClose{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCommand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientCommandResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &StateMachineCommandResponse_ClientCommand{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientConnectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientConnectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientConnectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.SessionTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientConnectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientConnectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientConnectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= ClientID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientKeepAliveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientKeepAliveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientKeepAliveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= ClientID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, SessionState{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingRequests", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingRequests = append(m.PendingRequests[:0], dAtA[iNdEx:postIndex]...)
			if m.PendingRequests == nil {
				m.PendingRequests = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseStreams = append(m.ResponseStreams, StreamState{})
			if err := m.ResponseStreams[len(m.ResponseStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompleteResponseID", wireType)
			}
			m.CompleteResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompleteResponseID |= ResponseID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientKeepAliveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientKeepAliveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientKeepAliveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCloseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCloseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCloseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= ClientID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCloseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCloseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCloseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCommandRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCommandRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCommandRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= ClientID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionOpenRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &ClientCommandRequest_SessionOpen{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionCloseRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &ClientCommandRequest_SessionClose{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCommand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionCommandRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &ClientCommandRequest_SessionCommand{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientCommandResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientCommandResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientCommandResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionOpenResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &ClientCommandResponse_SessionOpen{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionClose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionCloseResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &ClientCommandResponse_SessionClose{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionCommand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionCommandResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &ClientCommandResponse_SessionCommand{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionOpenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionOpenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionOpenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionOpenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionOpenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionOpenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionCloseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionCloseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionCloseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionCloseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionCloseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionCloseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionCommandRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionCommandRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionCommandRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OperationRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SessionCommandRequest_Operation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionCommandResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionCommandResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionCommandResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseID", wireType)
			}
			m.ResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseID |= ResponseID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OperationResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SessionCommandResponse_Operation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncIndex", wireType)
			}
			m.SyncIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncIndex |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientQueryRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &StateMachineQueryRequest_ClientQuery{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClientQueryResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &StateMachineQueryResponse_ClientQuery{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= ClientID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionQueryRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &ClientQueryRequest_SessionQuery{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionQueryResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &ClientQueryResponse_SessionQuery{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRequestID", wireType)
			}
			m.LastRequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OperationRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SessionQueryRequest_Operation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseID", wireType)
			}
			m.ResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseID |= ResponseID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OperationResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SessionQueryResponse_Operation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationID", wireType)
			}
			m.OperationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationID |= OperationID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ResponseCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupService = fmt.Errorf("proto: unexpected end of group")
)
