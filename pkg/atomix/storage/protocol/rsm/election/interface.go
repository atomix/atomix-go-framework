// Code generated by atomix-go-framework. DO NOT EDIT.
package election

import (
	"fmt"
	election "github.com/atomix/atomix-api/go/atomix/primitive/election"
	errors "github.com/atomix/atomix-go-framework/pkg/atomix/errors"
	rsm "github.com/atomix/atomix-go-framework/pkg/atomix/storage/protocol/rsm"
	util "github.com/atomix/atomix-go-framework/pkg/atomix/util"
	proto "github.com/golang/protobuf/proto"
	uuid "github.com/google/uuid"
	"io"
)

type Service interface {
	ServiceContext
	Backup(SnapshotWriter) error
	Restore(SnapshotReader) error
	// Enter enters the leader election
	Enter(EnterProposal) error
	// Withdraw withdraws a candidate from the leader election
	Withdraw(WithdrawProposal) error
	// Anoint anoints a candidate leader
	Anoint(AnointProposal) error
	// Promote promotes a candidate
	Promote(PromoteProposal) error
	// Evict evicts a candidate from the election
	Evict(EvictProposal) error
	// GetTerm gets the current leadership term
	GetTerm(GetTermProposal) error
	// Events listens for leadership events
	Events(EventsProposal) error
}

type ServiceContext interface {
	Scheduler() rsm.Scheduler
	Sessions() Sessions
	Proposals() Proposals
}

func newServiceContext(scheduler rsm.Scheduler) ServiceContext {
	return &serviceContext{
		scheduler: scheduler,
		sessions:  newSessions(),
		proposals: newProposals(),
	}
}

type serviceContext struct {
	scheduler rsm.Scheduler
	sessions  Sessions
	proposals Proposals
}

func (s *serviceContext) Scheduler() rsm.Scheduler {
	return s.scheduler
}

func (s *serviceContext) Sessions() Sessions {
	return s.sessions
}

func (s *serviceContext) Proposals() Proposals {
	return s.proposals
}

var _ ServiceContext = &serviceContext{}

type SnapshotWriter interface {
	WriteState(*LeaderElectionState) error
}

func newSnapshotWriter(writer io.Writer) SnapshotWriter {
	return &serviceSnapshotWriter{
		writer: writer,
	}
}

type serviceSnapshotWriter struct {
	writer io.Writer
}

func (w *serviceSnapshotWriter) WriteState(state *LeaderElectionState) error {
	bytes, err := proto.Marshal(state)
	if err != nil {
		return err
	}
	err = util.WriteBytes(w.writer, bytes)
	if err != nil {
		return err
	}
	return err
}

var _ SnapshotWriter = &serviceSnapshotWriter{}

type SnapshotReader interface {
	ReadState() (*LeaderElectionState, error)
}

func newSnapshotReader(reader io.Reader) SnapshotReader {
	return &serviceSnapshotReader{
		reader: reader,
	}
}

type serviceSnapshotReader struct {
	reader io.Reader
}

func (r *serviceSnapshotReader) ReadState() (*LeaderElectionState, error) {
	bytes, err := util.ReadBytes(r.reader)
	if err != nil {
		return nil, err
	}
	state := &LeaderElectionState{}
	err = proto.Unmarshal(bytes, state)
	if err != nil {
		return nil, err
	}
	return state, nil
}

var _ SnapshotReader = &serviceSnapshotReader{}

type Sessions interface {
	open(Session)
	expire(SessionID)
	close(SessionID)
	Get(SessionID) (Session, bool)
	List() []Session
}

func newSessions() Sessions {
	return &serviceSessions{
		sessions: make(map[SessionID]Session),
	}
}

type serviceSessions struct {
	sessions map[SessionID]Session
}

func (s *serviceSessions) open(session Session) {
	s.sessions[session.ID()] = session
	session.setState(SessionOpen)
}

func (s *serviceSessions) expire(sessionID SessionID) {
	session, ok := s.sessions[sessionID]
	if ok {
		session.setState(SessionClosed)
		delete(s.sessions, sessionID)
	}
}

func (s *serviceSessions) close(sessionID SessionID) {
	session, ok := s.sessions[sessionID]
	if ok {
		session.setState(SessionClosed)
		delete(s.sessions, sessionID)
	}
}

func (s *serviceSessions) Get(id SessionID) (Session, bool) {
	session, ok := s.sessions[id]
	return session, ok
}

func (s *serviceSessions) List() []Session {
	sessions := make([]Session, 0, len(s.sessions))
	for _, session := range s.sessions {
		sessions = append(sessions, session)
	}
	return sessions
}

var _ Sessions = &serviceSessions{}

type SessionID uint64

type SessionState int

const (
	SessionClosed SessionState = iota
	SessionOpen
)

type Watcher interface {
	Cancel()
}

func newWatcher(f func()) Watcher {
	return &serviceWatcher{
		f: f,
	}
}

type serviceWatcher struct {
	f func()
}

func (s *serviceWatcher) Cancel() {
	s.f()
}

var _ Watcher = &serviceWatcher{}

type Session interface {
	ID() SessionID
	State() SessionState
	setState(SessionState)
	Watch(func(SessionState)) Watcher
	Proposals() Proposals
}

func newSession(session rsm.Session) Session {
	return &serviceSession{
		session:   session,
		proposals: newProposals(),
		watchers:  make(map[string]func(SessionState)),
	}
}

type serviceSession struct {
	session   rsm.Session
	proposals Proposals
	state     SessionState
	watchers  map[string]func(SessionState)
}

func (s *serviceSession) ID() SessionID {
	return SessionID(s.session.ID())
}

func (s *serviceSession) Proposals() Proposals {
	return s.proposals
}

func (s *serviceSession) State() SessionState {
	return s.state
}

func (s *serviceSession) setState(state SessionState) {
	if state != s.state {
		s.state = state
		for _, watcher := range s.watchers {
			watcher(state)
		}
	}
}

func (s *serviceSession) Watch(f func(SessionState)) Watcher {
	id := uuid.New().String()
	s.watchers[id] = f
	return newWatcher(func() {
		delete(s.watchers, id)
	})
}

var _ Session = &serviceSession{}

type Proposals interface {
	Enter() EnterProposals
	Withdraw() WithdrawProposals
	Anoint() AnointProposals
	Promote() PromoteProposals
	Evict() EvictProposals
	GetTerm() GetTermProposals
	Events() EventsProposals
}

func newProposals() Proposals {
	return &serviceProposals{
		enterProposals:    newEnterProposals(),
		withdrawProposals: newWithdrawProposals(),
		anointProposals:   newAnointProposals(),
		promoteProposals:  newPromoteProposals(),
		evictProposals:    newEvictProposals(),
		getTermProposals:  newGetTermProposals(),
		eventsProposals:   newEventsProposals(),
	}
}

type serviceProposals struct {
	enterProposals    EnterProposals
	withdrawProposals WithdrawProposals
	anointProposals   AnointProposals
	promoteProposals  PromoteProposals
	evictProposals    EvictProposals
	getTermProposals  GetTermProposals
	eventsProposals   EventsProposals
}

func (s *serviceProposals) Enter() EnterProposals {
	return s.enterProposals
}
func (s *serviceProposals) Withdraw() WithdrawProposals {
	return s.withdrawProposals
}
func (s *serviceProposals) Anoint() AnointProposals {
	return s.anointProposals
}
func (s *serviceProposals) Promote() PromoteProposals {
	return s.promoteProposals
}
func (s *serviceProposals) Evict() EvictProposals {
	return s.evictProposals
}
func (s *serviceProposals) GetTerm() GetTermProposals {
	return s.getTermProposals
}
func (s *serviceProposals) Events() EventsProposals {
	return s.eventsProposals
}

var _ Proposals = &serviceProposals{}

type ProposalID uint64

type Proposal interface {
	fmt.Stringer
	ID() ProposalID
	Session() Session
}

func newProposal(id ProposalID, session Session) Proposal {
	return &serviceProposal{
		id:      id,
		session: session,
	}
}

type serviceProposal struct {
	id      ProposalID
	session Session
}

func (p *serviceProposal) ID() ProposalID {
	return p.id
}

func (p *serviceProposal) Session() Session {
	return p.session
}

func (p *serviceProposal) String() string {
	return fmt.Sprintf("ProposalID: %d, SessionID: %d", p.id, p.session.ID())
}

var _ Proposal = &serviceProposal{}

type EnterProposals interface {
	register(EnterProposal)
	unregister(ProposalID)
	Get(ProposalID) (EnterProposal, bool)
	List() []EnterProposal
}

func newEnterProposals() EnterProposals {
	return &enterProposals{
		proposals: make(map[ProposalID]EnterProposal),
	}
}

type enterProposals struct {
	proposals map[ProposalID]EnterProposal
}

func (p *enterProposals) register(proposal EnterProposal) {
	p.proposals[proposal.ID()] = proposal
}

func (p *enterProposals) unregister(id ProposalID) {
	delete(p.proposals, id)
}

func (p *enterProposals) Get(id ProposalID) (EnterProposal, bool) {
	proposal, ok := p.proposals[id]
	return proposal, ok
}

func (p *enterProposals) List() []EnterProposal {
	proposals := make([]EnterProposal, 0, len(p.proposals))
	for _, proposal := range p.proposals {
		proposals = append(proposals, proposal)
	}
	return proposals
}

var _ EnterProposals = &enterProposals{}

type EnterProposal interface {
	Proposal
	Request() *election.EnterRequest
	Reply(*election.EnterResponse) error
	response() *election.EnterResponse
}

func newEnterProposal(id ProposalID, session Session, request *election.EnterRequest) EnterProposal {
	return &enterProposal{
		Proposal: newProposal(id, session),
		req:      request,
	}
}

type enterProposal struct {
	Proposal
	req *election.EnterRequest
	res *election.EnterResponse
}

func (p *enterProposal) Request() *election.EnterRequest {
	return p.req
}

func (p *enterProposal) Reply(reply *election.EnterResponse) error {
	if p.res != nil {
		return errors.NewConflict("reply already sent")
	}
	log.Debugf("Accepted EnterProposal %s: %s", p, reply)
	p.res = reply
	return nil
}

func (p *enterProposal) response() *election.EnterResponse {
	return p.res
}

func (p *enterProposal) String() string {
	return fmt.Sprintf("ProposalID=%d, SessionID=%d, Request=%s", p.ID(), p.Session().ID(), p.req)
}

var _ EnterProposal = &enterProposal{}

type WithdrawProposals interface {
	register(WithdrawProposal)
	unregister(ProposalID)
	Get(ProposalID) (WithdrawProposal, bool)
	List() []WithdrawProposal
}

func newWithdrawProposals() WithdrawProposals {
	return &withdrawProposals{
		proposals: make(map[ProposalID]WithdrawProposal),
	}
}

type withdrawProposals struct {
	proposals map[ProposalID]WithdrawProposal
}

func (p *withdrawProposals) register(proposal WithdrawProposal) {
	p.proposals[proposal.ID()] = proposal
}

func (p *withdrawProposals) unregister(id ProposalID) {
	delete(p.proposals, id)
}

func (p *withdrawProposals) Get(id ProposalID) (WithdrawProposal, bool) {
	proposal, ok := p.proposals[id]
	return proposal, ok
}

func (p *withdrawProposals) List() []WithdrawProposal {
	proposals := make([]WithdrawProposal, 0, len(p.proposals))
	for _, proposal := range p.proposals {
		proposals = append(proposals, proposal)
	}
	return proposals
}

var _ WithdrawProposals = &withdrawProposals{}

type WithdrawProposal interface {
	Proposal
	Request() *election.WithdrawRequest
	Reply(*election.WithdrawResponse) error
	response() *election.WithdrawResponse
}

func newWithdrawProposal(id ProposalID, session Session, request *election.WithdrawRequest) WithdrawProposal {
	return &withdrawProposal{
		Proposal: newProposal(id, session),
		req:      request,
	}
}

type withdrawProposal struct {
	Proposal
	req *election.WithdrawRequest
	res *election.WithdrawResponse
}

func (p *withdrawProposal) Request() *election.WithdrawRequest {
	return p.req
}

func (p *withdrawProposal) Reply(reply *election.WithdrawResponse) error {
	if p.res != nil {
		return errors.NewConflict("reply already sent")
	}
	log.Debugf("Accepted WithdrawProposal %s: %s", p, reply)
	p.res = reply
	return nil
}

func (p *withdrawProposal) response() *election.WithdrawResponse {
	return p.res
}

func (p *withdrawProposal) String() string {
	return fmt.Sprintf("ProposalID=%d, SessionID=%d, Request=%s", p.ID(), p.Session().ID(), p.req)
}

var _ WithdrawProposal = &withdrawProposal{}

type AnointProposals interface {
	register(AnointProposal)
	unregister(ProposalID)
	Get(ProposalID) (AnointProposal, bool)
	List() []AnointProposal
}

func newAnointProposals() AnointProposals {
	return &anointProposals{
		proposals: make(map[ProposalID]AnointProposal),
	}
}

type anointProposals struct {
	proposals map[ProposalID]AnointProposal
}

func (p *anointProposals) register(proposal AnointProposal) {
	p.proposals[proposal.ID()] = proposal
}

func (p *anointProposals) unregister(id ProposalID) {
	delete(p.proposals, id)
}

func (p *anointProposals) Get(id ProposalID) (AnointProposal, bool) {
	proposal, ok := p.proposals[id]
	return proposal, ok
}

func (p *anointProposals) List() []AnointProposal {
	proposals := make([]AnointProposal, 0, len(p.proposals))
	for _, proposal := range p.proposals {
		proposals = append(proposals, proposal)
	}
	return proposals
}

var _ AnointProposals = &anointProposals{}

type AnointProposal interface {
	Proposal
	Request() *election.AnointRequest
	Reply(*election.AnointResponse) error
	response() *election.AnointResponse
}

func newAnointProposal(id ProposalID, session Session, request *election.AnointRequest) AnointProposal {
	return &anointProposal{
		Proposal: newProposal(id, session),
		req:      request,
	}
}

type anointProposal struct {
	Proposal
	req *election.AnointRequest
	res *election.AnointResponse
}

func (p *anointProposal) Request() *election.AnointRequest {
	return p.req
}

func (p *anointProposal) Reply(reply *election.AnointResponse) error {
	if p.res != nil {
		return errors.NewConflict("reply already sent")
	}
	log.Debugf("Accepted AnointProposal %s: %s", p, reply)
	p.res = reply
	return nil
}

func (p *anointProposal) response() *election.AnointResponse {
	return p.res
}

func (p *anointProposal) String() string {
	return fmt.Sprintf("ProposalID=%d, SessionID=%d, Request=%s", p.ID(), p.Session().ID(), p.req)
}

var _ AnointProposal = &anointProposal{}

type PromoteProposals interface {
	register(PromoteProposal)
	unregister(ProposalID)
	Get(ProposalID) (PromoteProposal, bool)
	List() []PromoteProposal
}

func newPromoteProposals() PromoteProposals {
	return &promoteProposals{
		proposals: make(map[ProposalID]PromoteProposal),
	}
}

type promoteProposals struct {
	proposals map[ProposalID]PromoteProposal
}

func (p *promoteProposals) register(proposal PromoteProposal) {
	p.proposals[proposal.ID()] = proposal
}

func (p *promoteProposals) unregister(id ProposalID) {
	delete(p.proposals, id)
}

func (p *promoteProposals) Get(id ProposalID) (PromoteProposal, bool) {
	proposal, ok := p.proposals[id]
	return proposal, ok
}

func (p *promoteProposals) List() []PromoteProposal {
	proposals := make([]PromoteProposal, 0, len(p.proposals))
	for _, proposal := range p.proposals {
		proposals = append(proposals, proposal)
	}
	return proposals
}

var _ PromoteProposals = &promoteProposals{}

type PromoteProposal interface {
	Proposal
	Request() *election.PromoteRequest
	Reply(*election.PromoteResponse) error
	response() *election.PromoteResponse
}

func newPromoteProposal(id ProposalID, session Session, request *election.PromoteRequest) PromoteProposal {
	return &promoteProposal{
		Proposal: newProposal(id, session),
		req:      request,
	}
}

type promoteProposal struct {
	Proposal
	req *election.PromoteRequest
	res *election.PromoteResponse
}

func (p *promoteProposal) Request() *election.PromoteRequest {
	return p.req
}

func (p *promoteProposal) Reply(reply *election.PromoteResponse) error {
	if p.res != nil {
		return errors.NewConflict("reply already sent")
	}
	log.Debugf("Accepted PromoteProposal %s: %s", p, reply)
	p.res = reply
	return nil
}

func (p *promoteProposal) response() *election.PromoteResponse {
	return p.res
}

func (p *promoteProposal) String() string {
	return fmt.Sprintf("ProposalID=%d, SessionID=%d, Request=%s", p.ID(), p.Session().ID(), p.req)
}

var _ PromoteProposal = &promoteProposal{}

type EvictProposals interface {
	register(EvictProposal)
	unregister(ProposalID)
	Get(ProposalID) (EvictProposal, bool)
	List() []EvictProposal
}

func newEvictProposals() EvictProposals {
	return &evictProposals{
		proposals: make(map[ProposalID]EvictProposal),
	}
}

type evictProposals struct {
	proposals map[ProposalID]EvictProposal
}

func (p *evictProposals) register(proposal EvictProposal) {
	p.proposals[proposal.ID()] = proposal
}

func (p *evictProposals) unregister(id ProposalID) {
	delete(p.proposals, id)
}

func (p *evictProposals) Get(id ProposalID) (EvictProposal, bool) {
	proposal, ok := p.proposals[id]
	return proposal, ok
}

func (p *evictProposals) List() []EvictProposal {
	proposals := make([]EvictProposal, 0, len(p.proposals))
	for _, proposal := range p.proposals {
		proposals = append(proposals, proposal)
	}
	return proposals
}

var _ EvictProposals = &evictProposals{}

type EvictProposal interface {
	Proposal
	Request() *election.EvictRequest
	Reply(*election.EvictResponse) error
	response() *election.EvictResponse
}

func newEvictProposal(id ProposalID, session Session, request *election.EvictRequest) EvictProposal {
	return &evictProposal{
		Proposal: newProposal(id, session),
		req:      request,
	}
}

type evictProposal struct {
	Proposal
	req *election.EvictRequest
	res *election.EvictResponse
}

func (p *evictProposal) Request() *election.EvictRequest {
	return p.req
}

func (p *evictProposal) Reply(reply *election.EvictResponse) error {
	if p.res != nil {
		return errors.NewConflict("reply already sent")
	}
	log.Debugf("Accepted EvictProposal %s: %s", p, reply)
	p.res = reply
	return nil
}

func (p *evictProposal) response() *election.EvictResponse {
	return p.res
}

func (p *evictProposal) String() string {
	return fmt.Sprintf("ProposalID=%d, SessionID=%d, Request=%s", p.ID(), p.Session().ID(), p.req)
}

var _ EvictProposal = &evictProposal{}

type GetTermProposals interface {
	register(GetTermProposal)
	unregister(ProposalID)
	Get(ProposalID) (GetTermProposal, bool)
	List() []GetTermProposal
}

func newGetTermProposals() GetTermProposals {
	return &getTermProposals{
		proposals: make(map[ProposalID]GetTermProposal),
	}
}

type getTermProposals struct {
	proposals map[ProposalID]GetTermProposal
}

func (p *getTermProposals) register(proposal GetTermProposal) {
	p.proposals[proposal.ID()] = proposal
}

func (p *getTermProposals) unregister(id ProposalID) {
	delete(p.proposals, id)
}

func (p *getTermProposals) Get(id ProposalID) (GetTermProposal, bool) {
	proposal, ok := p.proposals[id]
	return proposal, ok
}

func (p *getTermProposals) List() []GetTermProposal {
	proposals := make([]GetTermProposal, 0, len(p.proposals))
	for _, proposal := range p.proposals {
		proposals = append(proposals, proposal)
	}
	return proposals
}

var _ GetTermProposals = &getTermProposals{}

type GetTermProposal interface {
	Proposal
	Request() *election.GetTermRequest
	Reply(*election.GetTermResponse) error
	response() *election.GetTermResponse
}

func newGetTermProposal(id ProposalID, session Session, request *election.GetTermRequest) GetTermProposal {
	return &getTermProposal{
		Proposal: newProposal(id, session),
		req:      request,
	}
}

type getTermProposal struct {
	Proposal
	req *election.GetTermRequest
	res *election.GetTermResponse
}

func (p *getTermProposal) Request() *election.GetTermRequest {
	return p.req
}

func (p *getTermProposal) Reply(reply *election.GetTermResponse) error {
	if p.res != nil {
		return errors.NewConflict("reply already sent")
	}
	log.Debugf("Accepted GetTermProposal %s: %s", p, reply)
	p.res = reply
	return nil
}

func (p *getTermProposal) response() *election.GetTermResponse {
	return p.res
}

func (p *getTermProposal) String() string {
	return fmt.Sprintf("ProposalID=%d, SessionID=%d, Request=%s", p.ID(), p.Session().ID(), p.req)
}

var _ GetTermProposal = &getTermProposal{}

type EventsProposals interface {
	register(EventsProposal)
	unregister(ProposalID)
	Get(ProposalID) (EventsProposal, bool)
	List() []EventsProposal
}

func newEventsProposals() EventsProposals {
	return &eventsProposals{
		proposals: make(map[ProposalID]EventsProposal),
	}
}

type eventsProposals struct {
	proposals map[ProposalID]EventsProposal
}

func (p *eventsProposals) register(proposal EventsProposal) {
	p.proposals[proposal.ID()] = proposal
}

func (p *eventsProposals) unregister(id ProposalID) {
	delete(p.proposals, id)
}

func (p *eventsProposals) Get(id ProposalID) (EventsProposal, bool) {
	proposal, ok := p.proposals[id]
	return proposal, ok
}

func (p *eventsProposals) List() []EventsProposal {
	proposals := make([]EventsProposal, 0, len(p.proposals))
	for _, proposal := range p.proposals {
		proposals = append(proposals, proposal)
	}
	return proposals
}

var _ EventsProposals = &eventsProposals{}

type EventsProposal interface {
	Proposal
	Request() *election.EventsRequest
	Notify(*election.EventsResponse) error
	Close() error
}

func newEventsProposal(id ProposalID, session Session, request *election.EventsRequest, stream rsm.Stream) EventsProposal {
	return &eventsProposal{
		Proposal: newProposal(id, session),
		request:  request,
		stream:   stream,
	}
}

type eventsProposal struct {
	Proposal
	request *election.EventsRequest
	stream  rsm.Stream
}

func (p *eventsProposal) Request() *election.EventsRequest {
	return p.request
}

func (p *eventsProposal) Notify(notification *election.EventsResponse) error {
	log.Debugf("Notifying EventsProposal %s: %s", p, notification)
	bytes, err := proto.Marshal(notification)
	if err != nil {
		return err
	}
	p.stream.Value(bytes)
	return nil
}

func (p *eventsProposal) Close() error {
	p.stream.Close()
	return nil
}

func (p *eventsProposal) String() string {
	return fmt.Sprintf("ProposalID=%d, SessionID=%d, Request=%s", p.ID(), p.Session().ID(), p.request)
}

var _ EventsProposal = &eventsProposal{}
